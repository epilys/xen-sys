/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __XEN_LATEST_INTERFACE_VERSION__: u32 = 265728;
pub const __XEN_INTERFACE_VERSION__: u32 = 265728;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __BITS_PER_LONG: u32 = 64;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT_MAX: i32 = -1;
pub const ULONG_MAX: i32 = -1;
pub const FLAT_RING3_CS32: u32 = 57379;
pub const FLAT_RING3_CS64: u32 = 57395;
pub const FLAT_RING3_DS32: u32 = 57387;
pub const FLAT_RING3_DS64: u32 = 0;
pub const FLAT_RING3_SS32: u32 = 57387;
pub const FLAT_RING3_SS64: u32 = 57387;
pub const FLAT_KERNEL_DS64: u32 = 0;
pub const FLAT_KERNEL_DS32: u32 = 57387;
pub const FLAT_KERNEL_DS: u32 = 0;
pub const FLAT_KERNEL_CS64: u32 = 57395;
pub const FLAT_KERNEL_CS32: u32 = 57379;
pub const FLAT_KERNEL_CS: u32 = 57395;
pub const FLAT_KERNEL_SS64: u32 = 57387;
pub const FLAT_KERNEL_SS32: u32 = 57387;
pub const FLAT_KERNEL_SS: u32 = 57387;
pub const FLAT_USER_DS64: u32 = 0;
pub const FLAT_USER_DS32: u32 = 57387;
pub const FLAT_USER_DS: u32 = 0;
pub const FLAT_USER_CS64: u32 = 57395;
pub const FLAT_USER_CS32: u32 = 57379;
pub const FLAT_USER_CS: u32 = 57395;
pub const FLAT_USER_SS64: u32 = 57387;
pub const FLAT_USER_SS32: u32 = 57387;
pub const FLAT_USER_SS: u32 = 57387;
pub const __HYPERVISOR_VIRT_START: i64 = -140737488355328;
pub const __HYPERVISOR_VIRT_END: i64 = -131941395333120;
pub const __MACH2PHYS_VIRT_START: i64 = -140737488355328;
pub const __MACH2PHYS_VIRT_END: i64 = -140462610448384;
pub const SEGBASE_FS: u32 = 0;
pub const SEGBASE_GS_USER: u32 = 1;
pub const SEGBASE_GS_KERNEL: u32 = 2;
pub const SEGBASE_GS_USER_SEL: u32 = 3;
pub const _VGCF_in_syscall: u32 = 8;
pub const VGCF_in_syscall: u32 = 256;
pub const VGCF_IN_SYSCALL: u32 = 256;
pub const PRI_xen_pfn: &[u8; 3usize] = b"lx\0";
pub const PRIu_xen_pfn: &[u8; 3usize] = b"lu\0";
pub const XEN_HAVE_PV_GUEST_ENTRY: u32 = 1;
pub const XEN_HAVE_PV_UPCALL_MASK: u32 = 1;
pub const FIRST_RESERVED_GDT_PAGE: u32 = 14;
pub const FIRST_RESERVED_GDT_BYTE: u32 = 57344;
pub const FIRST_RESERVED_GDT_ENTRY: u32 = 7168;
pub const XEN_LEGACY_MAX_VCPUS: u32 = 32;
pub const PRI_xen_ulong: &[u8; 3usize] = b"lx\0";
pub const VGCF_I387_VALID: u32 = 1;
pub const VGCF_IN_KERNEL: u32 = 4;
pub const _VGCF_i387_valid: u32 = 0;
pub const VGCF_i387_valid: u32 = 1;
pub const _VGCF_in_kernel: u32 = 2;
pub const VGCF_in_kernel: u32 = 4;
pub const _VGCF_failsafe_disables_events: u32 = 3;
pub const VGCF_failsafe_disables_events: u32 = 8;
pub const _VGCF_syscall_disables_events: u32 = 4;
pub const VGCF_syscall_disables_events: u32 = 16;
pub const _VGCF_online: u32 = 5;
pub const VGCF_online: u32 = 32;
pub const _XEN_X86_EMU_LAPIC: u32 = 0;
pub const XEN_X86_EMU_LAPIC: u32 = 1;
pub const _XEN_X86_EMU_HPET: u32 = 1;
pub const XEN_X86_EMU_HPET: u32 = 2;
pub const _XEN_X86_EMU_PM: u32 = 2;
pub const XEN_X86_EMU_PM: u32 = 4;
pub const _XEN_X86_EMU_RTC: u32 = 3;
pub const XEN_X86_EMU_RTC: u32 = 8;
pub const _XEN_X86_EMU_IOAPIC: u32 = 4;
pub const XEN_X86_EMU_IOAPIC: u32 = 16;
pub const _XEN_X86_EMU_PIC: u32 = 5;
pub const XEN_X86_EMU_PIC: u32 = 32;
pub const _XEN_X86_EMU_VGA: u32 = 6;
pub const XEN_X86_EMU_VGA: u32 = 64;
pub const _XEN_X86_EMU_IOMMU: u32 = 7;
pub const XEN_X86_EMU_IOMMU: u32 = 128;
pub const _XEN_X86_EMU_PIT: u32 = 8;
pub const XEN_X86_EMU_PIT: u32 = 256;
pub const _XEN_X86_EMU_USE_PIRQ: u32 = 9;
pub const XEN_X86_EMU_USE_PIRQ: u32 = 512;
pub const _XEN_X86_EMU_VPCI: u32 = 10;
pub const XEN_X86_EMU_VPCI: u32 = 1024;
pub const XEN_X86_EMU_ALL: u32 = 2047;
pub const XEN_X86_MSR_RELAXED: u32 = 1;
pub const XEN_X86_MISC_FLAGS_MAX: u32 = 1;
pub const XEN_CPUID_NO_SUBLEAF: u32 = 4294967295;
pub const XEN_EMULATE_PREFIX: &[u8; 34usize] = b".byte 0x0f,0x0b,0x78,0x65,0x6e ; \0";
pub const XEN_CPUID: &[u8; 39usize] = b".byte 0x0f,0x0b,0x78,0x65,0x6e ; cpuid\0";
pub const XEN_HVM_DEBUGCONS_IOPORT: u32 = 233;
pub const __HYPERVISOR_set_trap_table: u32 = 0;
pub const __HYPERVISOR_mmu_update: u32 = 1;
pub const __HYPERVISOR_set_gdt: u32 = 2;
pub const __HYPERVISOR_stack_switch: u32 = 3;
pub const __HYPERVISOR_set_callbacks: u32 = 4;
pub const __HYPERVISOR_fpu_taskswitch: u32 = 5;
pub const __HYPERVISOR_sched_op_compat: u32 = 6;
pub const __HYPERVISOR_platform_op: u32 = 7;
pub const __HYPERVISOR_set_debugreg: u32 = 8;
pub const __HYPERVISOR_get_debugreg: u32 = 9;
pub const __HYPERVISOR_update_descriptor: u32 = 10;
pub const __HYPERVISOR_memory_op: u32 = 12;
pub const __HYPERVISOR_multicall: u32 = 13;
pub const __HYPERVISOR_update_va_mapping: u32 = 14;
pub const __HYPERVISOR_set_timer_op: u32 = 15;
pub const __HYPERVISOR_event_channel_op_compat: u32 = 16;
pub const __HYPERVISOR_xen_version: u32 = 17;
pub const __HYPERVISOR_console_io: u32 = 18;
pub const __HYPERVISOR_physdev_op_compat: u32 = 19;
pub const __HYPERVISOR_grant_table_op: u32 = 20;
pub const __HYPERVISOR_vm_assist: u32 = 21;
pub const __HYPERVISOR_update_va_mapping_otherdomain: u32 = 22;
pub const __HYPERVISOR_iret: u32 = 23;
pub const __HYPERVISOR_vcpu_op: u32 = 24;
pub const __HYPERVISOR_set_segment_base: u32 = 25;
pub const __HYPERVISOR_mmuext_op: u32 = 26;
pub const __HYPERVISOR_xsm_op: u32 = 27;
pub const __HYPERVISOR_nmi_op: u32 = 28;
pub const __HYPERVISOR_sched_op: u32 = 29;
pub const __HYPERVISOR_callback_op: u32 = 30;
pub const __HYPERVISOR_xenoprof_op: u32 = 31;
pub const __HYPERVISOR_event_channel_op: u32 = 32;
pub const __HYPERVISOR_physdev_op: u32 = 33;
pub const __HYPERVISOR_hvm_op: u32 = 34;
pub const __HYPERVISOR_sysctl: u32 = 35;
pub const __HYPERVISOR_domctl: u32 = 36;
pub const __HYPERVISOR_kexec_op: u32 = 37;
pub const __HYPERVISOR_tmem_op: u32 = 38;
pub const __HYPERVISOR_argo_op: u32 = 39;
pub const __HYPERVISOR_xenpmu_op: u32 = 40;
pub const __HYPERVISOR_dm_op: u32 = 41;
pub const __HYPERVISOR_hypfs_op: u32 = 42;
pub const __HYPERVISOR_arch_0: u32 = 48;
pub const __HYPERVISOR_arch_1: u32 = 49;
pub const __HYPERVISOR_arch_2: u32 = 50;
pub const __HYPERVISOR_arch_3: u32 = 51;
pub const __HYPERVISOR_arch_4: u32 = 52;
pub const __HYPERVISOR_arch_5: u32 = 53;
pub const __HYPERVISOR_arch_6: u32 = 54;
pub const __HYPERVISOR_arch_7: u32 = 55;
pub const VIRQ_TIMER: u32 = 0;
pub const VIRQ_DEBUG: u32 = 1;
pub const VIRQ_CONSOLE: u32 = 2;
pub const VIRQ_DOM_EXC: u32 = 3;
pub const VIRQ_TBUF: u32 = 4;
pub const VIRQ_DEBUGGER: u32 = 6;
pub const VIRQ_XENOPROF: u32 = 7;
pub const VIRQ_CON_RING: u32 = 8;
pub const VIRQ_PCPU_STATE: u32 = 9;
pub const VIRQ_MEM_EVENT: u32 = 10;
pub const VIRQ_ARGO: u32 = 11;
pub const VIRQ_ENOMEM: u32 = 12;
pub const VIRQ_XENPMU: u32 = 13;
pub const VIRQ_ARCH_0: u32 = 16;
pub const VIRQ_ARCH_1: u32 = 17;
pub const VIRQ_ARCH_2: u32 = 18;
pub const VIRQ_ARCH_3: u32 = 19;
pub const VIRQ_ARCH_4: u32 = 20;
pub const VIRQ_ARCH_5: u32 = 21;
pub const VIRQ_ARCH_6: u32 = 22;
pub const VIRQ_ARCH_7: u32 = 23;
pub const NR_VIRQS: u32 = 24;
pub const MMU_NORMAL_PT_UPDATE: u32 = 0;
pub const MMU_MACHPHYS_UPDATE: u32 = 1;
pub const MMU_PT_UPDATE_PRESERVE_AD: u32 = 2;
pub const MMU_PT_UPDATE_NO_TRANSLATE: u32 = 3;
pub const MMUEXT_PIN_L1_TABLE: u32 = 0;
pub const MMUEXT_PIN_L2_TABLE: u32 = 1;
pub const MMUEXT_PIN_L3_TABLE: u32 = 2;
pub const MMUEXT_PIN_L4_TABLE: u32 = 3;
pub const MMUEXT_UNPIN_TABLE: u32 = 4;
pub const MMUEXT_NEW_BASEPTR: u32 = 5;
pub const MMUEXT_TLB_FLUSH_LOCAL: u32 = 6;
pub const MMUEXT_INVLPG_LOCAL: u32 = 7;
pub const MMUEXT_TLB_FLUSH_MULTI: u32 = 8;
pub const MMUEXT_INVLPG_MULTI: u32 = 9;
pub const MMUEXT_TLB_FLUSH_ALL: u32 = 10;
pub const MMUEXT_INVLPG_ALL: u32 = 11;
pub const MMUEXT_FLUSH_CACHE: u32 = 12;
pub const MMUEXT_SET_LDT: u32 = 13;
pub const MMUEXT_NEW_USER_BASEPTR: u32 = 15;
pub const MMUEXT_CLEAR_PAGE: u32 = 16;
pub const MMUEXT_COPY_PAGE: u32 = 17;
pub const MMUEXT_FLUSH_CACHE_GLOBAL: u32 = 18;
pub const MMUEXT_MARK_SUPER: u32 = 19;
pub const MMUEXT_UNMARK_SUPER: u32 = 20;
pub const CONSOLEIO_write: u32 = 0;
pub const CONSOLEIO_read: u32 = 1;
pub const VMASST_CMD_enable: u32 = 0;
pub const VMASST_CMD_disable: u32 = 1;
pub const VMASST_TYPE_4gb_segments: u32 = 0;
pub const VMASST_TYPE_4gb_segments_notify: u32 = 1;
pub const VMASST_TYPE_writable_pagetables: u32 = 2;
pub const VMASST_TYPE_pae_extended_cr3: u32 = 3;
pub const VMASST_TYPE_architectural_iopl: u32 = 4;
pub const VMASST_TYPE_runstate_update_flag: u32 = 5;
pub const VMASST_TYPE_m2p_strict: u32 = 32;
pub const XEN_PVCLOCK_TSC_STABLE_BIT: u32 = 1;
pub const XEN_PVCLOCK_GUEST_STOPPED: u32 = 2;
pub const MAX_GUEST_CMDLINE: u32 = 1024;
pub const SIF_PRIVILEGED: u32 = 1;
pub const SIF_INITDOMAIN: u32 = 2;
pub const SIF_MULTIBOOT_MOD: u32 = 4;
pub const SIF_MOD_START_PFN: u32 = 8;
pub const SIF_VIRT_P2M_4TOOLS: u32 = 16;
pub const SIF_PM_MASK: u32 = 65280;
pub const XEN_VGATYPE_TEXT_MODE_3: u32 = 3;
pub const XEN_VGATYPE_VESA_LFB: u32 = 35;
pub const XEN_VGATYPE_EFI_LFB: u32 = 112;
pub const EVTCHNOP_bind_interdomain: u32 = 0;
pub const EVTCHNOP_bind_virq: u32 = 1;
pub const EVTCHNOP_bind_pirq: u32 = 2;
pub const EVTCHNOP_close: u32 = 3;
pub const EVTCHNOP_send: u32 = 4;
pub const EVTCHNOP_status: u32 = 5;
pub const EVTCHNOP_alloc_unbound: u32 = 6;
pub const EVTCHNOP_bind_ipi: u32 = 7;
pub const EVTCHNOP_bind_vcpu: u32 = 8;
pub const EVTCHNOP_unmask: u32 = 9;
pub const EVTCHNOP_reset: u32 = 10;
pub const EVTCHNOP_init_control: u32 = 11;
pub const EVTCHNOP_expand_array: u32 = 12;
pub const EVTCHNOP_set_priority: u32 = 13;
pub const BIND_PIRQ__WILL_SHARE: u32 = 1;
pub const EVTCHNSTAT_closed: u32 = 0;
pub const EVTCHNSTAT_unbound: u32 = 1;
pub const EVTCHNSTAT_interdomain: u32 = 2;
pub const EVTCHNSTAT_pirq: u32 = 3;
pub const EVTCHNSTAT_virq: u32 = 4;
pub const EVTCHNSTAT_ipi: u32 = 5;
pub const EVTCHN_FIFO_PRIORITY_MAX: u32 = 0;
pub const EVTCHN_FIFO_PRIORITY_DEFAULT: u32 = 7;
pub const EVTCHN_FIFO_PRIORITY_MIN: u32 = 15;
pub const EVTCHN_FIFO_MAX_QUEUES: u32 = 16;
pub const EVTCHN_FIFO_PENDING: u32 = 31;
pub const EVTCHN_FIFO_MASKED: u32 = 30;
pub const EVTCHN_FIFO_LINKED: u32 = 29;
pub const EVTCHN_FIFO_BUSY: u32 = 28;
pub const EVTCHN_FIFO_LINK_BITS: u32 = 17;
pub const EVTCHN_FIFO_LINK_MASK: u32 = 131071;
pub const EVTCHN_FIFO_NR_CHANNELS: u32 = 131072;
pub const GNTTAB_NR_RESERVED_ENTRIES: u32 = 8;
pub const GNTTAB_RESERVED_CONSOLE: u32 = 0;
pub const GNTTAB_RESERVED_XENSTORE: u32 = 1;
pub const GTF_invalid: u32 = 0;
pub const GTF_permit_access: u32 = 1;
pub const GTF_accept_transfer: u32 = 2;
pub const GTF_transitive: u32 = 3;
pub const GTF_type_mask: u32 = 3;
pub const _GTF_readonly: u32 = 2;
pub const GTF_readonly: u32 = 4;
pub const _GTF_reading: u32 = 3;
pub const GTF_reading: u32 = 8;
pub const _GTF_writing: u32 = 4;
pub const GTF_writing: u32 = 16;
pub const _GTF_PWT: u32 = 5;
pub const GTF_PWT: u32 = 32;
pub const _GTF_PCD: u32 = 6;
pub const GTF_PCD: u32 = 64;
pub const _GTF_PAT: u32 = 7;
pub const GTF_PAT: u32 = 128;
pub const _GTF_sub_page: u32 = 8;
pub const GTF_sub_page: u32 = 256;
pub const _GTF_transfer_committed: u32 = 2;
pub const GTF_transfer_committed: u32 = 4;
pub const _GTF_transfer_completed: u32 = 3;
pub const GTF_transfer_completed: u32 = 8;
pub const GNTTABOP_map_grant_ref: u32 = 0;
pub const GNTTABOP_unmap_grant_ref: u32 = 1;
pub const GNTTABOP_setup_table: u32 = 2;
pub const GNTTABOP_dump_table: u32 = 3;
pub const GNTTABOP_transfer: u32 = 4;
pub const GNTTABOP_copy: u32 = 5;
pub const GNTTABOP_query_size: u32 = 6;
pub const GNTTABOP_unmap_and_replace: u32 = 7;
pub const GNTTABOP_set_version: u32 = 8;
pub const GNTTABOP_get_status_frames: u32 = 9;
pub const GNTTABOP_get_version: u32 = 10;
pub const GNTTABOP_swap_grant_ref: u32 = 11;
pub const GNTTABOP_cache_flush: u32 = 12;
pub const _GNTCOPY_source_gref: u32 = 0;
pub const GNTCOPY_source_gref: u32 = 1;
pub const _GNTCOPY_dest_gref: u32 = 1;
pub const GNTCOPY_dest_gref: u32 = 2;
pub const GNTTAB_CACHE_CLEAN: u32 = 1;
pub const GNTTAB_CACHE_INVAL: u32 = 2;
pub const GNTTAB_CACHE_SOURCE_GREF: u32 = 2147483648;
pub const _GNTMAP_device_map: u32 = 0;
pub const GNTMAP_device_map: u32 = 1;
pub const _GNTMAP_host_map: u32 = 1;
pub const GNTMAP_host_map: u32 = 2;
pub const _GNTMAP_readonly: u32 = 2;
pub const GNTMAP_readonly: u32 = 4;
pub const _GNTMAP_application_map: u32 = 3;
pub const GNTMAP_application_map: u32 = 8;
pub const _GNTMAP_contains_pte: u32 = 4;
pub const GNTMAP_contains_pte: u32 = 16;
pub const _GNTMAP_guest_avail0: u32 = 16;
pub const GNTST_okay: u32 = 0;
pub const GNTST_general_error: i32 = -1;
pub const GNTST_bad_domain: i32 = -2;
pub const GNTST_bad_gntref: i32 = -3;
pub const GNTST_bad_handle: i32 = -4;
pub const GNTST_bad_virt_addr: i32 = -5;
pub const GNTST_bad_dev_addr: i32 = -6;
pub const GNTST_no_device_space: i32 = -7;
pub const GNTST_permission_denied: i32 = -8;
pub const GNTST_bad_page: i32 = -9;
pub const GNTST_bad_copy_arg: i32 = -10;
pub const GNTST_address_too_big: i32 = -11;
pub const GNTST_eagain: i32 = -12;
pub const GNTST_no_space: i32 = -13;
pub const HVM_FILE_MAGIC: u32 = 1412960902;
pub const HVM_FILE_VERSION: u32 = 1;
pub const _XEN_X86_FPU_INITIALISED: u32 = 0;
pub const XEN_X86_FPU_INITIALISED: u32 = 1;
pub const VIOAPIC_NUM_PINS: u32 = 48;
pub const RTC_CMOS_SIZE: u32 = 14;
pub const HPET_TIMER_NUM: u32 = 3;
pub const MTRR_VCNT: u32 = 8;
pub const NUM_FIXED_MSR: u32 = 11;
pub const CPU_XSAVE_CODE: u32 = 16;
pub const CPU_MSR_CODE: u32 = 20;
pub const HVM_SAVE_CODE_MAX: u32 = 20;
pub const PHYSDEVOP_eoi: u32 = 12;
pub const PHYSDEVOP_pirq_eoi_gmfn_v1: u32 = 17;
pub const PHYSDEVOP_pirq_eoi_gmfn_v2: u32 = 28;
pub const PHYSDEVOP_irq_status_query: u32 = 5;
pub const _XENIRQSTAT_needs_eoi: u32 = 0;
pub const XENIRQSTAT_needs_eoi: u32 = 1;
pub const _XENIRQSTAT_shared: u32 = 1;
pub const XENIRQSTAT_shared: u32 = 2;
pub const PHYSDEVOP_set_iopl: u32 = 6;
pub const PHYSDEVOP_set_iobitmap: u32 = 7;
pub const PHYSDEVOP_apic_read: u32 = 8;
pub const PHYSDEVOP_apic_write: u32 = 9;
pub const PHYSDEVOP_alloc_irq_vector: u32 = 10;
pub const PHYSDEVOP_free_irq_vector: u32 = 11;
pub const MAP_PIRQ_TYPE_MSI: u32 = 0;
pub const MAP_PIRQ_TYPE_GSI: u32 = 1;
pub const MAP_PIRQ_TYPE_UNKNOWN: u32 = 2;
pub const MAP_PIRQ_TYPE_MSI_SEG: u32 = 3;
pub const MAP_PIRQ_TYPE_MULTI_MSI: u32 = 4;
pub const PHYSDEVOP_map_pirq: u32 = 13;
pub const PHYSDEVOP_unmap_pirq: u32 = 14;
pub const PHYSDEVOP_manage_pci_add: u32 = 15;
pub const PHYSDEVOP_manage_pci_remove: u32 = 16;
pub const PHYSDEVOP_restore_msi: u32 = 19;
pub const PHYSDEVOP_manage_pci_add_ext: u32 = 20;
pub const PHYSDEVOP_setup_gsi: u32 = 21;
pub const PHYSDEVOP_get_free_pirq: u32 = 23;
pub const XEN_PCI_MMCFG_RESERVED: u32 = 1;
pub const PHYSDEVOP_pci_mmcfg_reserved: u32 = 24;
pub const XEN_PCI_DEV_EXTFN: u32 = 1;
pub const XEN_PCI_DEV_VIRTFN: u32 = 2;
pub const XEN_PCI_DEV_PXM: u32 = 4;
pub const PHYSDEVOP_pci_device_add: u32 = 25;
pub const PHYSDEVOP_pci_device_remove: u32 = 26;
pub const PHYSDEVOP_restore_msi_ext: u32 = 27;
pub const PHYSDEVOP_prepare_msix: u32 = 30;
pub const PHYSDEVOP_release_msix: u32 = 31;
pub const PHYSDEVOP_DBGP_RESET_PREPARE: u32 = 1;
pub const PHYSDEVOP_DBGP_RESET_DONE: u32 = 2;
pub const PHYSDEVOP_DBGP_BUS_UNKNOWN: u32 = 0;
pub const PHYSDEVOP_DBGP_BUS_PCI: u32 = 1;
pub const PHYSDEVOP_dbgp_op: u32 = 29;
pub const PHYSDEVOP_IRQ_UNMASK_NOTIFY: u32 = 4;
pub const PHYSDEVOP_pirq_eoi_gmfn: u32 = 28;
pub const XENMEM_increase_reservation: u32 = 0;
pub const XENMEM_decrease_reservation: u32 = 1;
pub const XENMEM_populate_physmap: u32 = 6;
pub const XENMEMF_populate_on_demand: u32 = 65536;
pub const XENMEMF_exact_node_request: u32 = 131072;
pub const XENMEMF_vnode: u32 = 262144;
pub const XENMEM_exchange: u32 = 11;
pub const XENMEM_maximum_ram_page: u32 = 2;
pub const XENMEM_current_reservation: u32 = 3;
pub const XENMEM_maximum_reservation: u32 = 4;
pub const XENMEM_maximum_gpfn: u32 = 14;
pub const XENMEM_machphys_mfn_list: u32 = 5;
pub const XENMEM_machphys_compat_mfn_list: u32 = 25;
pub const XENMEM_machphys_mapping: u32 = 12;
pub const XENMAPSPACE_shared_info: u32 = 0;
pub const XENMAPSPACE_grant_table: u32 = 1;
pub const XENMAPSPACE_gmfn: u32 = 2;
pub const XENMAPSPACE_gmfn_range: u32 = 3;
pub const XENMAPSPACE_gmfn_foreign: u32 = 4;
pub const XENMAPSPACE_dev_mmio: u32 = 5;
pub const XENMEM_add_to_physmap: u32 = 7;
pub const XENMAPIDX_grant_table_status: u32 = 2147483648;
pub const XENMEM_add_to_physmap_batch: u32 = 23;
pub const XENMEM_remove_from_physmap: u32 = 15;
pub const XENMEM_memory_map: u32 = 9;
pub const XENMEM_machine_memory_map: u32 = 10;
pub const XENMEM_set_memory_map: u32 = 13;
pub const XENMEM_set_pod_target: u32 = 16;
pub const XENMEM_get_pod_target: u32 = 17;
pub const XENMEM_get_sharing_freed_pages: u32 = 18;
pub const XENMEM_get_sharing_shared_pages: u32 = 19;
pub const XENMEM_paging_op: u32 = 20;
pub const XENMEM_paging_op_nominate: u32 = 0;
pub const XENMEM_paging_op_evict: u32 = 1;
pub const XENMEM_paging_op_prep: u32 = 2;
pub const XENMEM_access_op: u32 = 21;
pub const XENMEM_access_op_set_access: u32 = 0;
pub const XENMEM_access_op_get_access: u32 = 1;
pub const XENMEM_access_op_set_access_multi: u32 = 4;
pub const XENMEM_sharing_op: u32 = 22;
pub const XENMEM_sharing_op_nominate_gfn: u32 = 0;
pub const XENMEM_sharing_op_nominate_gref: u32 = 1;
pub const XENMEM_sharing_op_share: u32 = 2;
pub const XENMEM_sharing_op_debug_gfn: u32 = 3;
pub const XENMEM_sharing_op_debug_mfn: u32 = 4;
pub const XENMEM_sharing_op_debug_gref: u32 = 5;
pub const XENMEM_sharing_op_add_physmap: u32 = 6;
pub const XENMEM_sharing_op_audit: u32 = 7;
pub const XENMEM_sharing_op_range_share: u32 = 8;
pub const XENMEM_sharing_op_fork: u32 = 9;
pub const XENMEM_sharing_op_fork_reset: u32 = 10;
pub const XENMEM_SHARING_OP_S_HANDLE_INVALID: i32 = -10;
pub const XENMEM_SHARING_OP_C_HANDLE_INVALID: i32 = -9;
pub const XENMEM_FORK_WITH_IOMMU_ALLOWED: u32 = 1;
pub const XENMEM_FORK_BLOCK_INTERRUPTS: u32 = 2;
pub const XENMEM_FORK_RESET_STATE: u32 = 4;
pub const XENMEM_FORK_RESET_MEMORY: u32 = 8;
pub const XENMEM_claim_pages: u32 = 24;
pub const XENMEM_reserved_device_memory_map: u32 = 27;
pub const XENMEM_RDM_ALL: u32 = 1;
pub const XENMEM_acquire_resource: u32 = 28;
pub const XENMEM_resource_ioreq_server: u32 = 0;
pub const XENMEM_resource_grant_table: u32 = 1;
pub const XENMEM_resource_vmtrace_buf: u32 = 2;
pub const XENMEM_resource_grant_table_id_shared: u32 = 0;
pub const XENMEM_resource_grant_table_id_status: u32 = 1;
pub const XENMEM_resource_ioreq_server_frame_bufioreq: u32 = 0;
pub const XENMEM_get_vnumainfo: u32 = 26;
pub const XEN_DOMCTL_INTERFACE_VERSION: u32 = 22;
pub const _XEN_DOMCTL_CDF_hvm: u32 = 0;
pub const XEN_DOMCTL_CDF_hvm: u32 = 1;
pub const _XEN_DOMCTL_CDF_hap: u32 = 1;
pub const XEN_DOMCTL_CDF_hap: u32 = 2;
pub const _XEN_DOMCTL_CDF_s3_integrity: u32 = 2;
pub const XEN_DOMCTL_CDF_s3_integrity: u32 = 4;
pub const _XEN_DOMCTL_CDF_oos_off: u32 = 3;
pub const XEN_DOMCTL_CDF_oos_off: u32 = 8;
pub const _XEN_DOMCTL_CDF_xs_domain: u32 = 4;
pub const XEN_DOMCTL_CDF_xs_domain: u32 = 16;
pub const _XEN_DOMCTL_CDF_iommu: u32 = 5;
pub const XEN_DOMCTL_CDF_iommu: u32 = 32;
pub const _XEN_DOMCTL_CDF_nested_virt: u32 = 6;
pub const XEN_DOMCTL_CDF_nested_virt: u32 = 64;
pub const XEN_DOMCTL_CDF_vpmu: u32 = 128;
pub const XEN_DOMCTL_CDF_MAX: u32 = 128;
pub const _XEN_DOMCTL_IOMMU_no_sharept: u32 = 0;
pub const XEN_DOMCTL_IOMMU_no_sharept: u32 = 1;
pub const XEN_DOMCTL_IOMMU_MAX: u32 = 1;
pub const XEN_DOMCTL_GRANT_version_mask: u32 = 15;
pub const _XEN_DOMINF_dying: u32 = 0;
pub const XEN_DOMINF_dying: u32 = 1;
pub const _XEN_DOMINF_hvm_guest: u32 = 1;
pub const XEN_DOMINF_hvm_guest: u32 = 2;
pub const _XEN_DOMINF_shutdown: u32 = 2;
pub const XEN_DOMINF_shutdown: u32 = 4;
pub const _XEN_DOMINF_paused: u32 = 3;
pub const XEN_DOMINF_paused: u32 = 8;
pub const _XEN_DOMINF_blocked: u32 = 4;
pub const XEN_DOMINF_blocked: u32 = 16;
pub const _XEN_DOMINF_running: u32 = 5;
pub const XEN_DOMINF_running: u32 = 32;
pub const _XEN_DOMINF_debugged: u32 = 6;
pub const XEN_DOMINF_debugged: u32 = 64;
pub const _XEN_DOMINF_xs_domain: u32 = 7;
pub const XEN_DOMINF_xs_domain: u32 = 128;
pub const _XEN_DOMINF_hap: u32 = 8;
pub const XEN_DOMINF_hap: u32 = 256;
pub const XEN_DOMINF_shutdownmask: u32 = 255;
pub const XEN_DOMINF_shutdownshift: u32 = 16;
pub const XEN_INVALID_MAX_VCPU_ID: i32 = -1;
pub const XEN_DOMCTL_PFINFO_LTAB_SHIFT: u32 = 28;
pub const XEN_DOMCTL_PFINFO_NOTAB: u32 = 0;
pub const XEN_DOMCTL_PFINFO_L1TAB: u32 = 268435456;
pub const XEN_DOMCTL_PFINFO_L2TAB: u32 = 536870912;
pub const XEN_DOMCTL_PFINFO_L3TAB: u32 = 805306368;
pub const XEN_DOMCTL_PFINFO_L4TAB: u32 = 1073741824;
pub const XEN_DOMCTL_PFINFO_LTABTYPE_MASK: u32 = 1879048192;
pub const XEN_DOMCTL_PFINFO_LPINTAB: u32 = 2147483648;
pub const XEN_DOMCTL_PFINFO_XTAB: u32 = 4026531840;
pub const XEN_DOMCTL_PFINFO_XALLOC: u32 = 3758096384;
pub const XEN_DOMCTL_PFINFO_BROKEN: u32 = 3489660928;
pub const XEN_DOMCTL_PFINFO_LTAB_MASK: u32 = 4026531840;
pub const XEN_DOMCTL_SHADOW_OP_OFF: u32 = 0;
pub const XEN_DOMCTL_SHADOW_OP_ENABLE: u32 = 32;
pub const XEN_DOMCTL_SHADOW_OP_CLEAN: u32 = 11;
pub const XEN_DOMCTL_SHADOW_OP_PEEK: u32 = 12;
pub const XEN_DOMCTL_SHADOW_OP_GET_ALLOCATION: u32 = 30;
pub const XEN_DOMCTL_SHADOW_OP_SET_ALLOCATION: u32 = 31;
pub const XEN_DOMCTL_SHADOW_OP_ENABLE_TEST: u32 = 1;
pub const XEN_DOMCTL_SHADOW_OP_ENABLE_LOGDIRTY: u32 = 2;
pub const XEN_DOMCTL_SHADOW_ENABLE_REFCOUNT: u32 = 2;
pub const XEN_DOMCTL_SHADOW_ENABLE_LOG_DIRTY: u32 = 4;
pub const XEN_DOMCTL_SHADOW_ENABLE_TRANSLATE: u32 = 8;
pub const XEN_DOMCTL_SHADOW_ENABLE_EXTERNAL: u32 = 16;
pub const XEN_DOMCTL_SHADOW_LOGDIRTY_FINAL: u32 = 1;
pub const _XEN_VCPUAFFINITY_HARD: u32 = 0;
pub const XEN_VCPUAFFINITY_HARD: u32 = 1;
pub const _XEN_VCPUAFFINITY_SOFT: u32 = 1;
pub const XEN_VCPUAFFINITY_SOFT: u32 = 2;
pub const _XEN_VCPUAFFINITY_FORCE: u32 = 2;
pub const XEN_VCPUAFFINITY_FORCE: u32 = 4;
pub const XEN_SCHEDULER_CREDIT: u32 = 5;
pub const XEN_SCHEDULER_CREDIT2: u32 = 6;
pub const XEN_SCHEDULER_ARINC653: u32 = 7;
pub const XEN_SCHEDULER_RTDS: u32 = 8;
pub const XEN_SCHEDULER_NULL: u32 = 9;
pub const _XEN_DOMCTL_SCHEDRT_extra: u32 = 0;
pub const XEN_DOMCTL_SCHEDRT_extra: u32 = 1;
pub const XEN_DOMCTL_SCHEDOP_putinfo: u32 = 0;
pub const XEN_DOMCTL_SCHEDOP_getinfo: u32 = 1;
pub const XEN_DOMCTL_SCHEDOP_putvcpuinfo: u32 = 2;
pub const XEN_DOMCTL_SCHEDOP_getvcpuinfo: u32 = 3;
pub const XEN_DOMCTL_SENDTRIGGER_NMI: u32 = 0;
pub const XEN_DOMCTL_SENDTRIGGER_RESET: u32 = 1;
pub const XEN_DOMCTL_SENDTRIGGER_INIT: u32 = 2;
pub const XEN_DOMCTL_SENDTRIGGER_POWER: u32 = 3;
pub const XEN_DOMCTL_SENDTRIGGER_SLEEP: u32 = 4;
pub const XEN_DOMCTL_DEV_PCI: u32 = 0;
pub const XEN_DOMCTL_DEV_DT: u32 = 1;
pub const XEN_DOMCTL_DEV_RDM_RELAXED: u32 = 1;
pub const XEN_DOMCTL_VMSI_X86_DEST_ID_MASK: u32 = 255;
pub const XEN_DOMCTL_VMSI_X86_RH_MASK: u32 = 256;
pub const XEN_DOMCTL_VMSI_X86_DM_MASK: u32 = 512;
pub const XEN_DOMCTL_VMSI_X86_DELIV_MASK: u32 = 28672;
pub const XEN_DOMCTL_VMSI_X86_TRIG_MASK: u32 = 32768;
pub const XEN_DOMCTL_VMSI_X86_UNMASKED: u32 = 65536;
pub const DPCI_ADD_MAPPING: u32 = 1;
pub const DPCI_REMOVE_MAPPING: u32 = 0;
pub const XEN_DOMCTL_MEM_CACHEATTR_UC: u32 = 0;
pub const XEN_DOMCTL_MEM_CACHEATTR_WC: u32 = 1;
pub const XEN_DOMCTL_MEM_CACHEATTR_WT: u32 = 4;
pub const XEN_DOMCTL_MEM_CACHEATTR_WP: u32 = 5;
pub const XEN_DOMCTL_MEM_CACHEATTR_WB: u32 = 6;
pub const XEN_DOMCTL_MEM_CACHEATTR_UCM: u32 = 7;
pub const XEN_CPUID_INPUT_UNUSED: u32 = 4294967295;
pub const XEN_DOMCTL_DEBUG_OP_SINGLE_STEP_OFF: u32 = 0;
pub const XEN_DOMCTL_DEBUG_OP_SINGLE_STEP_ON: u32 = 1;
pub const XEN_VM_EVENT_ENABLE: u32 = 0;
pub const XEN_VM_EVENT_DISABLE: u32 = 1;
pub const XEN_VM_EVENT_RESUME: u32 = 2;
pub const XEN_VM_EVENT_GET_VERSION: u32 = 3;
pub const XEN_DOMCTL_VM_EVENT_OP_PAGING: u32 = 1;
pub const XEN_DOMCTL_VM_EVENT_OP_MONITOR: u32 = 2;
pub const XEN_DOMCTL_VM_EVENT_OP_SHARING: u32 = 3;
pub const XEN_DOMCTL_MEM_SHARING_CONTROL: u32 = 0;
pub const XEN_DOMCTL_PSR_CMT_OP_DETACH: u32 = 0;
pub const XEN_DOMCTL_PSR_CMT_OP_ATTACH: u32 = 1;
pub const XEN_DOMCTL_PSR_CMT_OP_QUERY_RMID: u32 = 2;
pub const XEN_DOMCTL_MONITOR_OP_ENABLE: u32 = 0;
pub const XEN_DOMCTL_MONITOR_OP_DISABLE: u32 = 1;
pub const XEN_DOMCTL_MONITOR_OP_GET_CAPABILITIES: u32 = 2;
pub const XEN_DOMCTL_MONITOR_OP_EMULATE_EACH_REP: u32 = 3;
pub const XEN_DOMCTL_MONITOR_OP_CONTROL_REGISTERS: u32 = 4;
pub const XEN_DOMCTL_MONITOR_EVENT_WRITE_CTRLREG: u32 = 0;
pub const XEN_DOMCTL_MONITOR_EVENT_MOV_TO_MSR: u32 = 1;
pub const XEN_DOMCTL_MONITOR_EVENT_SINGLESTEP: u32 = 2;
pub const XEN_DOMCTL_MONITOR_EVENT_SOFTWARE_BREAKPOINT: u32 = 3;
pub const XEN_DOMCTL_MONITOR_EVENT_GUEST_REQUEST: u32 = 4;
pub const XEN_DOMCTL_MONITOR_EVENT_DEBUG_EXCEPTION: u32 = 5;
pub const XEN_DOMCTL_MONITOR_EVENT_CPUID: u32 = 6;
pub const XEN_DOMCTL_MONITOR_EVENT_PRIVILEGED_CALL: u32 = 7;
pub const XEN_DOMCTL_MONITOR_EVENT_INTERRUPT: u32 = 8;
pub const XEN_DOMCTL_MONITOR_EVENT_DESC_ACCESS: u32 = 9;
pub const XEN_DOMCTL_MONITOR_EVENT_EMUL_UNIMPLEMENTED: u32 = 10;
pub const XEN_DOMCTL_MONITOR_EVENT_INGUEST_PAGEFAULT: u32 = 11;
pub const XEN_DOMCTL_MONITOR_EVENT_VMEXIT: u32 = 12;
pub const XEN_DOMCTL_MONITOR_EVENT_IO: u32 = 13;
pub const XEN_DOMCTL_PSR_SET_L3_CBM: u32 = 0;
pub const XEN_DOMCTL_PSR_GET_L3_CBM: u32 = 1;
pub const XEN_DOMCTL_PSR_SET_L3_CODE: u32 = 2;
pub const XEN_DOMCTL_PSR_SET_L3_DATA: u32 = 3;
pub const XEN_DOMCTL_PSR_GET_L3_CODE: u32 = 4;
pub const XEN_DOMCTL_PSR_GET_L3_DATA: u32 = 5;
pub const XEN_DOMCTL_PSR_SET_L2_CBM: u32 = 6;
pub const XEN_DOMCTL_PSR_GET_L2_CBM: u32 = 7;
pub const XEN_DOMCTL_PSR_SET_MBA_THRTL: u32 = 8;
pub const XEN_DOMCTL_PSR_GET_MBA_THRTL: u32 = 9;
pub const XEN_DOMCTL_VUART_OP_INIT: u32 = 0;
pub const XEN_DOMCTL_VUART_TYPE_VPL011: u32 = 0;
pub const XEN_DOMCTL_vmtrace_enable: u32 = 1;
pub const XEN_DOMCTL_vmtrace_disable: u32 = 2;
pub const XEN_DOMCTL_vmtrace_reset_and_enable: u32 = 3;
pub const XEN_DOMCTL_vmtrace_output_position: u32 = 4;
pub const XEN_DOMCTL_vmtrace_get_option: u32 = 5;
pub const XEN_DOMCTL_vmtrace_set_option: u32 = 6;
pub const XEN_DOMCTL_createdomain: u32 = 1;
pub const XEN_DOMCTL_destroydomain: u32 = 2;
pub const XEN_DOMCTL_pausedomain: u32 = 3;
pub const XEN_DOMCTL_unpausedomain: u32 = 4;
pub const XEN_DOMCTL_getdomaininfo: u32 = 5;
pub const XEN_DOMCTL_setvcpuaffinity: u32 = 9;
pub const XEN_DOMCTL_shadow_op: u32 = 10;
pub const XEN_DOMCTL_max_mem: u32 = 11;
pub const XEN_DOMCTL_setvcpucontext: u32 = 12;
pub const XEN_DOMCTL_getvcpucontext: u32 = 13;
pub const XEN_DOMCTL_getvcpuinfo: u32 = 14;
pub const XEN_DOMCTL_max_vcpus: u32 = 15;
pub const XEN_DOMCTL_scheduler_op: u32 = 16;
pub const XEN_DOMCTL_setdomainhandle: u32 = 17;
pub const XEN_DOMCTL_setdebugging: u32 = 18;
pub const XEN_DOMCTL_irq_permission: u32 = 19;
pub const XEN_DOMCTL_iomem_permission: u32 = 20;
pub const XEN_DOMCTL_ioport_permission: u32 = 21;
pub const XEN_DOMCTL_hypercall_init: u32 = 22;
pub const XEN_DOMCTL_settimeoffset: u32 = 24;
pub const XEN_DOMCTL_getvcpuaffinity: u32 = 25;
pub const XEN_DOMCTL_real_mode_area: u32 = 26;
pub const XEN_DOMCTL_resumedomain: u32 = 27;
pub const XEN_DOMCTL_sendtrigger: u32 = 28;
pub const XEN_DOMCTL_subscribe: u32 = 29;
pub const XEN_DOMCTL_gethvmcontext: u32 = 33;
pub const XEN_DOMCTL_sethvmcontext: u32 = 34;
pub const XEN_DOMCTL_set_address_size: u32 = 35;
pub const XEN_DOMCTL_get_address_size: u32 = 36;
pub const XEN_DOMCTL_assign_device: u32 = 37;
pub const XEN_DOMCTL_bind_pt_irq: u32 = 38;
pub const XEN_DOMCTL_memory_mapping: u32 = 39;
pub const XEN_DOMCTL_ioport_mapping: u32 = 40;
pub const XEN_DOMCTL_set_ext_vcpucontext: u32 = 42;
pub const XEN_DOMCTL_get_ext_vcpucontext: u32 = 43;
pub const XEN_DOMCTL_set_opt_feature: u32 = 44;
pub const XEN_DOMCTL_test_assign_device: u32 = 45;
pub const XEN_DOMCTL_set_target: u32 = 46;
pub const XEN_DOMCTL_deassign_device: u32 = 47;
pub const XEN_DOMCTL_unbind_pt_irq: u32 = 48;
pub const XEN_DOMCTL_get_device_group: u32 = 50;
pub const XEN_DOMCTL_debug_op: u32 = 54;
pub const XEN_DOMCTL_gethvmcontext_partial: u32 = 55;
pub const XEN_DOMCTL_vm_event_op: u32 = 56;
pub const XEN_DOMCTL_mem_sharing_op: u32 = 57;
pub const XEN_DOMCTL_gettscinfo: u32 = 59;
pub const XEN_DOMCTL_settscinfo: u32 = 60;
pub const XEN_DOMCTL_getpageframeinfo3: u32 = 61;
pub const XEN_DOMCTL_setvcpuextstate: u32 = 62;
pub const XEN_DOMCTL_getvcpuextstate: u32 = 63;
pub const XEN_DOMCTL_set_access_required: u32 = 64;
pub const XEN_DOMCTL_audit_p2m: u32 = 65;
pub const XEN_DOMCTL_set_virq_handler: u32 = 66;
pub const XEN_DOMCTL_set_broken_page_p2m: u32 = 67;
pub const XEN_DOMCTL_setnodeaffinity: u32 = 68;
pub const XEN_DOMCTL_getnodeaffinity: u32 = 69;
pub const XEN_DOMCTL_cacheflush: u32 = 71;
pub const XEN_DOMCTL_get_vcpu_msrs: u32 = 72;
pub const XEN_DOMCTL_set_vcpu_msrs: u32 = 73;
pub const XEN_DOMCTL_setvnumainfo: u32 = 74;
pub const XEN_DOMCTL_psr_cmt_op: u32 = 75;
pub const XEN_DOMCTL_monitor_op: u32 = 77;
pub const XEN_DOMCTL_psr_alloc: u32 = 78;
pub const XEN_DOMCTL_soft_reset: u32 = 79;
pub const XEN_DOMCTL_vuart_op: u32 = 81;
pub const XEN_DOMCTL_get_cpu_policy: u32 = 82;
pub const XEN_DOMCTL_set_cpu_policy: u32 = 83;
pub const XEN_DOMCTL_vmtrace_op: u32 = 84;
pub const XEN_DOMCTL_get_paging_mempool_size: u32 = 85;
pub const XEN_DOMCTL_set_paging_mempool_size: u32 = 86;
pub const XEN_DOMCTL_gdbsx_guestmemio: u32 = 1000;
pub const XEN_DOMCTL_gdbsx_pausevcpu: u32 = 1001;
pub const XEN_DOMCTL_gdbsx_unpausevcpu: u32 = 1002;
pub const XEN_DOMCTL_gdbsx_domstatus: u32 = 1003;
pub const IOREQ_READ: u32 = 1;
pub const IOREQ_WRITE: u32 = 0;
pub const STATE_IOREQ_NONE: u32 = 0;
pub const STATE_IOREQ_READY: u32 = 1;
pub const STATE_IOREQ_INPROCESS: u32 = 2;
pub const STATE_IORESP_READY: u32 = 3;
pub const IOREQ_TYPE_PIO: u32 = 0;
pub const IOREQ_TYPE_COPY: u32 = 1;
pub const IOREQ_TYPE_PCI_CONFIG: u32 = 2;
pub const IOREQ_TYPE_TIMEOFFSET: u32 = 7;
pub const IOREQ_TYPE_INVALIDATE: u32 = 8;
pub const IOREQ_BUFFER_SLOT_NUM: u32 = 511;
pub const ACPI_PM1A_EVT_BLK_ADDRESS_V0: u32 = 8000;
pub const ACPI_PM1A_CNT_BLK_ADDRESS_V0: u32 = 8004;
pub const ACPI_PM_TMR_BLK_ADDRESS_V0: u32 = 8008;
pub const ACPI_GPE0_BLK_ADDRESS_V0: u32 = 8040;
pub const ACPI_GPE0_BLK_LEN_V0: u32 = 8;
pub const ACPI_PM1A_EVT_BLK_ADDRESS_V1: u32 = 45056;
pub const ACPI_PM1A_CNT_BLK_ADDRESS_V1: u32 = 45060;
pub const ACPI_PM_TMR_BLK_ADDRESS_V1: u32 = 45064;
pub const ACPI_GPE0_BLK_ADDRESS_V1: u32 = 45024;
pub const ACPI_GPE0_BLK_LEN_V1: u32 = 4;
pub const ACPI_PM1A_EVT_BLK_ADDRESS: u32 = 8000;
pub const ACPI_PM1A_CNT_BLK_ADDRESS: u32 = 8004;
pub const ACPI_PM_TMR_BLK_ADDRESS: u32 = 8008;
pub const ACPI_GPE0_BLK_ADDRESS: u32 = 8040;
pub const ACPI_GPE0_BLK_LEN: u32 = 8;
pub type __s8 = xen_bindings_x86_64_types::c_schar;
pub type __u8 = xen_bindings_x86_64_types::c_uchar;
pub type __s16 = xen_bindings_x86_64_types::c_short;
pub type __u16 = xen_bindings_x86_64_types::c_ushort;
pub type __s32 = xen_bindings_x86_64_types::c_int;
pub type __u32 = xen_bindings_x86_64_types::c_uint;
pub type __s64 = xen_bindings_x86_64_types::c_longlong;
pub type __u64 = xen_bindings_x86_64_types::c_ulonglong;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type bool_t = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iret_context {
    pub rax: u64,
    pub r11: u64,
    pub rcx: u64,
    pub flags: u64,
    pub rip: u64,
    pub cs: u64,
    pub rflags: u64,
    pub rsp: u64,
    pub ss: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu_user_regs {
    pub __bindgen_anon_1: cpu_user_regs__bindgen_ty_1,
    pub __bindgen_anon_2: cpu_user_regs__bindgen_ty_2,
    pub __bindgen_anon_3: cpu_user_regs__bindgen_ty_3,
    pub __bindgen_anon_4: cpu_user_regs__bindgen_ty_4,
    pub __bindgen_anon_5: cpu_user_regs__bindgen_ty_5,
    pub __bindgen_anon_6: cpu_user_regs__bindgen_ty_6,
    pub __bindgen_anon_7: cpu_user_regs__bindgen_ty_7,
    pub __bindgen_anon_8: cpu_user_regs__bindgen_ty_8,
    pub __bindgen_anon_9: cpu_user_regs__bindgen_ty_9,
    pub __bindgen_anon_10: cpu_user_regs__bindgen_ty_10,
    pub __bindgen_anon_11: cpu_user_regs__bindgen_ty_11,
    pub __bindgen_anon_12: cpu_user_regs__bindgen_ty_12,
    pub __bindgen_anon_13: cpu_user_regs__bindgen_ty_13,
    pub __bindgen_anon_14: cpu_user_regs__bindgen_ty_14,
    pub __bindgen_anon_15: cpu_user_regs__bindgen_ty_15,
    pub error_code: u32,
    pub entry_vector: u32,
    pub __bindgen_anon_16: cpu_user_regs__bindgen_ty_16,
    pub cs: u16,
    pub _pad0: [u16; 1usize],
    pub saved_upcall_mask: u8,
    pub _pad1: [u8; 3usize],
    pub __bindgen_anon_17: cpu_user_regs__bindgen_ty_17,
    pub __bindgen_anon_18: cpu_user_regs__bindgen_ty_18,
    pub ss: u16,
    pub _pad2: [u16; 3usize],
    pub es: u16,
    pub _pad3: [u16; 3usize],
    pub ds: u16,
    pub _pad4: [u16; 3usize],
    pub fs: u16,
    pub _pad5: [u16; 3usize],
    pub gs: u16,
    pub _pad6: [u16; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_1 {
    pub r15: u64,
    pub r15d: u32,
    pub r15w: u16,
    pub r15b: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_2 {
    pub r14: u64,
    pub r14d: u32,
    pub r14w: u16,
    pub r14b: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_3 {
    pub r13: u64,
    pub r13d: u32,
    pub r13w: u16,
    pub r13b: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_4 {
    pub r12: u64,
    pub r12d: u32,
    pub r12w: u16,
    pub r12b: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_5 {
    pub rbp: u64,
    pub ebp: u32,
    pub bp: u16,
    pub bpl: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_6 {
    pub rbx: u64,
    pub ebx: u32,
    pub bx: u16,
    pub __bindgen_anon_1: cpu_user_regs__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_user_regs__bindgen_ty_6__bindgen_ty_1 {
    pub bl: u8,
    pub bh: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_7 {
    pub r11: u64,
    pub r11d: u32,
    pub r11w: u16,
    pub r11b: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_8 {
    pub r10: u64,
    pub r10d: u32,
    pub r10w: u16,
    pub r10b: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_9 {
    pub r9: u64,
    pub r9d: u32,
    pub r9w: u16,
    pub r9b: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_10 {
    pub r8: u64,
    pub r8d: u32,
    pub r8w: u16,
    pub r8b: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_11 {
    pub rax: u64,
    pub eax: u32,
    pub ax: u16,
    pub __bindgen_anon_1: cpu_user_regs__bindgen_ty_11__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_user_regs__bindgen_ty_11__bindgen_ty_1 {
    pub al: u8,
    pub ah: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_12 {
    pub rcx: u64,
    pub ecx: u32,
    pub cx: u16,
    pub __bindgen_anon_1: cpu_user_regs__bindgen_ty_12__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_user_regs__bindgen_ty_12__bindgen_ty_1 {
    pub cl: u8,
    pub ch: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_13 {
    pub rdx: u64,
    pub edx: u32,
    pub dx: u16,
    pub __bindgen_anon_1: cpu_user_regs__bindgen_ty_13__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_user_regs__bindgen_ty_13__bindgen_ty_1 {
    pub dl: u8,
    pub dh: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_14 {
    pub rsi: u64,
    pub esi: u32,
    pub si: u16,
    pub sil: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_15 {
    pub rdi: u64,
    pub edi: u32,
    pub di: u16,
    pub dil: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_16 {
    pub rip: u64,
    pub eip: u32,
    pub ip: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_17 {
    pub rflags: u64,
    pub eflags: u32,
    pub flags: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cpu_user_regs__bindgen_ty_18 {
    pub rsp: u64,
    pub esp: u32,
    pub sp: u16,
    pub spl: u8,
}
pub type cpu_user_regs_t = cpu_user_regs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_cpu_user_regs_t {
    pub p: *mut cpu_user_regs_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_cpu_user_regs_t {
    pub p: *const cpu_user_regs_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_vcpu_info {
    pub cr2: xen_bindings_x86_64_types::c_ulong,
    pub pad: xen_bindings_x86_64_types::c_ulong,
}
pub type arch_vcpu_info_t = arch_vcpu_info;
pub type xen_callback_t = xen_bindings_x86_64_types::c_ulong;
pub type xen_pfn_t = xen_bindings_x86_64_types::c_ulong;
pub type xen_ulong_t = xen_bindings_x86_64_types::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trap_info {
    pub vector: u8,
    pub flags: u8,
    pub cs: u16,
    pub address: xen_bindings_x86_64_types::c_ulong,
}
pub type trap_info_t = trap_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_trap_info_t {
    pub p: *mut trap_info_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_trap_info_t {
    pub p: *const trap_info_t,
}
pub type tsc_timestamp_t = u64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vcpu_guest_context {
    pub fpu_ctxt: vcpu_guest_context__bindgen_ty_1,
    pub flags: xen_bindings_x86_64_types::c_ulong,
    pub user_regs: cpu_user_regs,
    pub trap_ctxt: [trap_info; 256usize],
    pub ldt_base: xen_bindings_x86_64_types::c_ulong,
    pub ldt_ents: xen_bindings_x86_64_types::c_ulong,
    pub gdt_frames: [xen_bindings_x86_64_types::c_ulong; 16usize],
    pub gdt_ents: xen_bindings_x86_64_types::c_ulong,
    pub kernel_ss: xen_bindings_x86_64_types::c_ulong,
    pub kernel_sp: xen_bindings_x86_64_types::c_ulong,
    pub ctrlreg: [xen_bindings_x86_64_types::c_ulong; 8usize],
    pub debugreg: [xen_bindings_x86_64_types::c_ulong; 8usize],
    pub event_callback_eip: xen_bindings_x86_64_types::c_ulong,
    pub failsafe_callback_eip: xen_bindings_x86_64_types::c_ulong,
    pub syscall_callback_eip: xen_bindings_x86_64_types::c_ulong,
    pub vm_assist: xen_bindings_x86_64_types::c_ulong,
    pub fs_base: u64,
    pub gs_base_kernel: u64,
    pub gs_base_user: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcpu_guest_context__bindgen_ty_1 {
    pub x: [xen_bindings_x86_64_types::c_char; 512usize],
}
pub type vcpu_guest_context_t = vcpu_guest_context;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_vcpu_guest_context_t {
    pub p: *mut vcpu_guest_context_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_vcpu_guest_context_t {
    pub p: *const vcpu_guest_context_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arch_shared_info {
    pub max_pfn: xen_bindings_x86_64_types::c_ulong,
    pub pfn_to_mfn_frame_list_list: xen_pfn_t,
    pub nmi_reason: xen_bindings_x86_64_types::c_ulong,
    pub p2m_cr3: xen_bindings_x86_64_types::c_ulong,
    pub p2m_vaddr: xen_bindings_x86_64_types::c_ulong,
    pub p2m_generation: xen_bindings_x86_64_types::c_ulong,
}
pub type arch_shared_info_t = arch_shared_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_arch_domainconfig {
    pub emulation_flags: u32,
    pub misc_flags: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_cpuid_leaf {
    pub leaf: u32,
    pub subleaf: u32,
    pub a: u32,
    pub b: u32,
    pub c: u32,
    pub d: u32,
}
pub type xen_cpuid_leaf_t = xen_cpuid_leaf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_cpuid_leaf_t {
    pub p: *mut xen_cpuid_leaf_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_cpuid_leaf_t {
    pub p: *const xen_cpuid_leaf_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_msr_entry {
    pub idx: u32,
    pub flags: u32,
    pub val: u64,
}
pub type xen_msr_entry_t = xen_msr_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_msr_entry_t {
    pub p: *mut xen_msr_entry_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_msr_entry_t {
    pub p: *const xen_msr_entry_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_char {
    pub p: *mut xen_bindings_x86_64_types::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_char {
    pub p: *const xen_bindings_x86_64_types::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_uchar {
    pub p: *mut xen_bindings_x86_64_types::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_uchar {
    pub p: *const xen_bindings_x86_64_types::c_uchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_int {
    pub p: *mut xen_bindings_x86_64_types::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_int {
    pub p: *const xen_bindings_x86_64_types::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_uint {
    pub p: *mut xen_bindings_x86_64_types::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_uint {
    pub p: *const xen_bindings_x86_64_types::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_void {
    pub p: *mut xen_bindings_x86_64_types::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_void {
    pub p: *const xen_bindings_x86_64_types::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_uint64_t {
    pub p: *mut u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_uint64_t {
    pub p: *const u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_pfn_t {
    pub p: *mut xen_pfn_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_pfn_t {
    pub p: *const xen_pfn_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_ulong_t {
    pub p: *mut xen_ulong_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_ulong_t {
    pub p: *const xen_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmuext_op {
    pub cmd: xen_bindings_x86_64_types::c_uint,
    pub arg1: mmuext_op__bindgen_ty_1,
    pub arg2: mmuext_op__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mmuext_op__bindgen_ty_1 {
    pub mfn: xen_pfn_t,
    pub linear_addr: xen_bindings_x86_64_types::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mmuext_op__bindgen_ty_2 {
    pub nr_ents: xen_bindings_x86_64_types::c_uint,
    pub vcpumask: __guest_handle_const_void,
    pub src_mfn: xen_pfn_t,
}
pub type mmuext_op_t = mmuext_op;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_mmuext_op_t {
    pub p: *mut mmuext_op_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_mmuext_op_t {
    pub p: *const mmuext_op_t,
}
pub type domid_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmu_update {
    pub ptr: u64,
    pub val: u64,
}
pub type mmu_update_t = mmu_update;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_mmu_update_t {
    pub p: *mut mmu_update_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_mmu_update_t {
    pub p: *const mmu_update_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct multicall_entry {
    pub op: xen_ulong_t,
    pub result: xen_ulong_t,
    pub args: [xen_ulong_t; 6usize],
}
pub type multicall_entry_t = multicall_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_multicall_entry_t {
    pub p: *mut multicall_entry_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_multicall_entry_t {
    pub p: *const multicall_entry_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcpu_time_info {
    pub version: u32,
    pub pad0: u32,
    pub tsc_timestamp: u64,
    pub system_time: u64,
    pub tsc_to_system_mul: u32,
    pub tsc_shift: i8,
    pub flags: u8,
    pub pad1: [u8; 2usize],
}
pub type vcpu_time_info_t = vcpu_time_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vcpu_info {
    pub evtchn_upcall_pending: u8,
    pub evtchn_upcall_mask: u8,
    pub evtchn_pending_sel: xen_ulong_t,
    pub arch: arch_vcpu_info,
    pub time: vcpu_time_info_t,
}
pub type vcpu_info_t = vcpu_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shared_info {
    pub vcpu_info: [vcpu_info; 32usize],
    pub evtchn_pending: [xen_ulong_t; 64usize],
    pub evtchn_mask: [xen_ulong_t; 64usize],
    pub wc_version: u32,
    pub wc_sec: u32,
    pub wc_nsec: u32,
    pub wc_sec_hi: u32,
    pub arch: arch_shared_info,
}
pub type shared_info_t = shared_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct start_info {
    pub magic: [xen_bindings_x86_64_types::c_char; 32usize],
    pub nr_pages: xen_bindings_x86_64_types::c_ulong,
    pub shared_info: xen_bindings_x86_64_types::c_ulong,
    pub flags: u32,
    pub store_mfn: xen_pfn_t,
    pub store_evtchn: u32,
    pub console: start_info__bindgen_ty_1,
    pub pt_base: xen_bindings_x86_64_types::c_ulong,
    pub nr_pt_frames: xen_bindings_x86_64_types::c_ulong,
    pub mfn_list: xen_bindings_x86_64_types::c_ulong,
    pub mod_start: xen_bindings_x86_64_types::c_ulong,
    pub mod_len: xen_bindings_x86_64_types::c_ulong,
    pub cmd_line: [i8; 1024usize],
    pub first_p2m_pfn: xen_bindings_x86_64_types::c_ulong,
    pub nr_p2m_frames: xen_bindings_x86_64_types::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union start_info__bindgen_ty_1 {
    pub domU: start_info__bindgen_ty_1__bindgen_ty_1,
    pub dom0: start_info__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct start_info__bindgen_ty_1__bindgen_ty_1 {
    pub mfn: xen_pfn_t,
    pub evtchn: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct start_info__bindgen_ty_1__bindgen_ty_2 {
    pub info_off: u32,
    pub info_size: u32,
}
pub type start_info_t = start_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_multiboot_mod_list {
    pub mod_start: u32,
    pub mod_end: u32,
    pub cmdline: u32,
    pub pad: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dom0_vga_console_info {
    pub video_type: u8,
    pub u: dom0_vga_console_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dom0_vga_console_info__bindgen_ty_1 {
    pub text_mode_3: dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1,
    pub vesa_lfb: dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dom0_vga_console_info__bindgen_ty_1__bindgen_ty_1 {
    pub font_height: u16,
    pub cursor_x: u16,
    pub cursor_y: u16,
    pub rows: u16,
    pub columns: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dom0_vga_console_info__bindgen_ty_1__bindgen_ty_2 {
    pub width: u16,
    pub height: u16,
    pub bytes_per_line: u16,
    pub bits_per_pixel: u16,
    pub lfb_base: u32,
    pub lfb_size: u32,
    pub red_pos: u8,
    pub red_size: u8,
    pub green_pos: u8,
    pub green_size: u8,
    pub blue_pos: u8,
    pub blue_size: u8,
    pub rsvd_pos: u8,
    pub rsvd_size: u8,
    pub gbl_caps: u32,
    pub mode_attrs: u16,
    pub pad: u16,
    pub ext_lfb_base: u32,
}
pub type dom0_vga_console_info_t = dom0_vga_console_info;
pub type xen_domain_handle_t = [u8; 16usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_uint8 {
    pub p: *mut u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_uint8 {
    pub p: *const u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_uint16 {
    pub p: *mut u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_uint16 {
    pub p: *const u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_uint32 {
    pub p: *mut u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_uint32 {
    pub p: *const u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_uint64 {
    pub p: *mut u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_uint64 {
    pub p: *const u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_uuid_t {
    pub a: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xenctl_bitmap {
    pub bitmap: __guest_handle_uint8,
    pub nr_bits: u32,
}
pub type xenctl_bitmap_t = xenctl_bitmap;
pub type evtchn_port_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_evtchn_port_t {
    pub p: *mut evtchn_port_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_evtchn_port_t {
    pub p: *const evtchn_port_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_alloc_unbound {
    pub dom: domid_t,
    pub remote_dom: domid_t,
    pub port: evtchn_port_t,
}
pub type evtchn_alloc_unbound_t = evtchn_alloc_unbound;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_bind_interdomain {
    pub remote_dom: domid_t,
    pub remote_port: evtchn_port_t,
    pub local_port: evtchn_port_t,
}
pub type evtchn_bind_interdomain_t = evtchn_bind_interdomain;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_bind_virq {
    pub virq: u32,
    pub vcpu: u32,
    pub port: evtchn_port_t,
}
pub type evtchn_bind_virq_t = evtchn_bind_virq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_bind_pirq {
    pub pirq: u32,
    pub flags: u32,
    pub port: evtchn_port_t,
}
pub type evtchn_bind_pirq_t = evtchn_bind_pirq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_bind_ipi {
    pub vcpu: u32,
    pub port: evtchn_port_t,
}
pub type evtchn_bind_ipi_t = evtchn_bind_ipi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_close {
    pub port: evtchn_port_t,
}
pub type evtchn_close_t = evtchn_close;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_send {
    pub port: evtchn_port_t,
}
pub type evtchn_send_t = evtchn_send;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct evtchn_status {
    pub dom: domid_t,
    pub port: evtchn_port_t,
    pub status: u32,
    pub vcpu: u32,
    pub u: evtchn_status__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union evtchn_status__bindgen_ty_1 {
    pub unbound: evtchn_status__bindgen_ty_1__bindgen_ty_1,
    pub interdomain: evtchn_status__bindgen_ty_1__bindgen_ty_2,
    pub pirq: u32,
    pub virq: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_status__bindgen_ty_1__bindgen_ty_1 {
    pub dom: domid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_status__bindgen_ty_1__bindgen_ty_2 {
    pub dom: domid_t,
    pub port: evtchn_port_t,
}
pub type evtchn_status_t = evtchn_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_bind_vcpu {
    pub port: evtchn_port_t,
    pub vcpu: u32,
}
pub type evtchn_bind_vcpu_t = evtchn_bind_vcpu;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_unmask {
    pub port: evtchn_port_t,
}
pub type evtchn_unmask_t = evtchn_unmask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_reset {
    pub dom: domid_t,
}
pub type evtchn_reset_t = evtchn_reset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_init_control {
    pub control_gfn: u64,
    pub offset: u32,
    pub vcpu: u32,
    pub link_bits: u8,
    pub _pad: [u8; 7usize],
}
pub type evtchn_init_control_t = evtchn_init_control;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_expand_array {
    pub array_gfn: u64,
}
pub type evtchn_expand_array_t = evtchn_expand_array;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_set_priority {
    pub port: evtchn_port_t,
    pub priority: u32,
}
pub type evtchn_set_priority_t = evtchn_set_priority;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct evtchn_op {
    pub cmd: u32,
    pub u: evtchn_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union evtchn_op__bindgen_ty_1 {
    pub alloc_unbound: evtchn_alloc_unbound_t,
    pub bind_interdomain: evtchn_bind_interdomain_t,
    pub bind_virq: evtchn_bind_virq_t,
    pub bind_pirq: evtchn_bind_pirq_t,
    pub bind_ipi: evtchn_bind_ipi_t,
    pub close: evtchn_close_t,
    pub send: evtchn_send_t,
    pub status: evtchn_status_t,
    pub bind_vcpu: evtchn_bind_vcpu_t,
    pub unmask: evtchn_unmask_t,
}
pub type evtchn_op_t = evtchn_op;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_evtchn_op_t {
    pub p: *mut evtchn_op_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_evtchn_op_t {
    pub p: *const evtchn_op_t,
}
pub type event_word_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct evtchn_fifo_control_block {
    pub ready: u32,
    pub _rsvd: u32,
    pub head: [u32; 16usize],
}
pub type evtchn_fifo_control_block_t = evtchn_fifo_control_block;
pub type grant_ref_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grant_entry_v1 {
    pub flags: u16,
    pub domid: domid_t,
    pub frame: u32,
}
pub type grant_entry_v1_t = grant_entry_v1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grant_entry_header {
    pub flags: u16,
    pub domid: domid_t,
}
pub type grant_entry_header_t = grant_entry_header;
#[repr(C)]
#[derive(Copy, Clone)]
pub union grant_entry_v2 {
    pub hdr: grant_entry_header_t,
    pub full_page: grant_entry_v2__bindgen_ty_1,
    pub sub_page: grant_entry_v2__bindgen_ty_2,
    pub transitive: grant_entry_v2__bindgen_ty_3,
    pub __spacer: [u32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grant_entry_v2__bindgen_ty_1 {
    pub hdr: grant_entry_header_t,
    pub pad0: u32,
    pub frame: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grant_entry_v2__bindgen_ty_2 {
    pub hdr: grant_entry_header_t,
    pub page_off: u16,
    pub length: u16,
    pub frame: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct grant_entry_v2__bindgen_ty_3 {
    pub hdr: grant_entry_header_t,
    pub trans_domid: domid_t,
    pub pad0: u16,
    pub gref: grant_ref_t,
}
pub type grant_entry_v2_t = grant_entry_v2;
pub type grant_status_t = u16;
pub type grant_handle_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnttab_map_grant_ref {
    pub host_addr: u64,
    pub flags: u32,
    pub ref_: grant_ref_t,
    pub dom: domid_t,
    pub status: i16,
    pub handle: grant_handle_t,
    pub dev_bus_addr: u64,
}
pub type gnttab_map_grant_ref_t = gnttab_map_grant_ref;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_gnttab_map_grant_ref_t {
    pub p: *mut gnttab_map_grant_ref_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_gnttab_map_grant_ref_t {
    pub p: *const gnttab_map_grant_ref_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnttab_unmap_grant_ref {
    pub host_addr: u64,
    pub dev_bus_addr: u64,
    pub handle: grant_handle_t,
    pub status: i16,
}
pub type gnttab_unmap_grant_ref_t = gnttab_unmap_grant_ref;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_gnttab_unmap_grant_ref_t {
    pub p: *mut gnttab_unmap_grant_ref_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_gnttab_unmap_grant_ref_t {
    pub p: *const gnttab_unmap_grant_ref_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnttab_setup_table {
    pub dom: domid_t,
    pub nr_frames: u32,
    pub status: i16,
    pub frame_list: __guest_handle_xen_pfn_t,
}
pub type gnttab_setup_table_t = gnttab_setup_table;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_gnttab_setup_table_t {
    pub p: *mut gnttab_setup_table_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_gnttab_setup_table_t {
    pub p: *const gnttab_setup_table_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnttab_dump_table {
    pub dom: domid_t,
    pub status: i16,
}
pub type gnttab_dump_table_t = gnttab_dump_table;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_gnttab_dump_table_t {
    pub p: *mut gnttab_dump_table_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_gnttab_dump_table_t {
    pub p: *const gnttab_dump_table_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnttab_transfer {
    pub mfn: xen_pfn_t,
    pub domid: domid_t,
    pub ref_: grant_ref_t,
    pub status: i16,
}
pub type gnttab_transfer_t = gnttab_transfer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_gnttab_transfer_t {
    pub p: *mut gnttab_transfer_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_gnttab_transfer_t {
    pub p: *const gnttab_transfer_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gnttab_copy {
    pub source: gnttab_copy_gnttab_copy_ptr,
    pub dest: gnttab_copy_gnttab_copy_ptr,
    pub len: u16,
    pub flags: u16,
    pub status: i16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gnttab_copy_gnttab_copy_ptr {
    pub u: gnttab_copy_gnttab_copy_ptr__bindgen_ty_1,
    pub domid: domid_t,
    pub offset: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gnttab_copy_gnttab_copy_ptr__bindgen_ty_1 {
    pub ref_: grant_ref_t,
    pub gmfn: xen_pfn_t,
}
pub type gnttab_copy_t = gnttab_copy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_gnttab_copy_t {
    pub p: *mut gnttab_copy_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_gnttab_copy_t {
    pub p: *const gnttab_copy_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnttab_query_size {
    pub dom: domid_t,
    pub nr_frames: u32,
    pub max_nr_frames: u32,
    pub status: i16,
}
pub type gnttab_query_size_t = gnttab_query_size;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_gnttab_query_size_t {
    pub p: *mut gnttab_query_size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_gnttab_query_size_t {
    pub p: *const gnttab_query_size_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnttab_unmap_and_replace {
    pub host_addr: u64,
    pub new_addr: u64,
    pub handle: grant_handle_t,
    pub status: i16,
}
pub type gnttab_unmap_and_replace_t = gnttab_unmap_and_replace;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_gnttab_unmap_and_replace_t {
    pub p: *mut gnttab_unmap_and_replace_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_gnttab_unmap_and_replace_t {
    pub p: *const gnttab_unmap_and_replace_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnttab_set_version {
    pub version: u32,
}
pub type gnttab_set_version_t = gnttab_set_version;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_gnttab_set_version_t {
    pub p: *mut gnttab_set_version_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_gnttab_set_version_t {
    pub p: *const gnttab_set_version_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnttab_get_status_frames {
    pub nr_frames: u32,
    pub dom: domid_t,
    pub status: i16,
    pub frame_list: __guest_handle_uint64_t,
}
pub type gnttab_get_status_frames_t = gnttab_get_status_frames;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_gnttab_get_status_frames_t {
    pub p: *mut gnttab_get_status_frames_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_gnttab_get_status_frames_t {
    pub p: *const gnttab_get_status_frames_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnttab_get_version {
    pub dom: domid_t,
    pub pad: u16,
    pub version: u32,
}
pub type gnttab_get_version_t = gnttab_get_version;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_gnttab_get_version_t {
    pub p: *mut gnttab_get_version_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_gnttab_get_version_t {
    pub p: *const gnttab_get_version_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gnttab_swap_grant_ref {
    pub ref_a: grant_ref_t,
    pub ref_b: grant_ref_t,
    pub status: i16,
}
pub type gnttab_swap_grant_ref_t = gnttab_swap_grant_ref;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_gnttab_swap_grant_ref_t {
    pub p: *mut gnttab_swap_grant_ref_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_gnttab_swap_grant_ref_t {
    pub p: *const gnttab_swap_grant_ref_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gnttab_cache_flush {
    pub a: gnttab_cache_flush__bindgen_ty_1,
    pub offset: u16,
    pub length: u16,
    pub op: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gnttab_cache_flush__bindgen_ty_1 {
    pub dev_bus_addr: u64,
    pub ref_: grant_ref_t,
}
pub type gnttab_cache_flush_t = gnttab_cache_flush;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_gnttab_cache_flush_t {
    pub p: *mut gnttab_cache_flush_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_gnttab_cache_flush_t {
    pub p: *const gnttab_cache_flush_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_save_descriptor {
    pub typecode: u16,
    pub instance: u16,
    pub length: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_save_end {}
#[repr(C)]
#[derive(Debug)]
pub struct __HVM_SAVE_TYPE_END {
    pub t: hvm_save_end,
    pub c: __IncompleteArrayField<xen_bindings_x86_64_types::c_char>,
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_save_header {
    pub magic: u32,
    pub version: u32,
    pub changeset: u64,
    pub cpuid: u32,
    pub gtsc_khz: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_HEADER {
    pub t: hvm_save_header,
    pub c: [xen_bindings_x86_64_types::c_char; 1usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hvm_hw_cpu {
    pub fpu_regs: [u8; 512usize],
    pub rax: u64,
    pub rbx: u64,
    pub rcx: u64,
    pub rdx: u64,
    pub rbp: u64,
    pub rsi: u64,
    pub rdi: u64,
    pub rsp: u64,
    pub r8: u64,
    pub r9: u64,
    pub r10: u64,
    pub r11: u64,
    pub r12: u64,
    pub r13: u64,
    pub r14: u64,
    pub r15: u64,
    pub rip: u64,
    pub rflags: u64,
    pub cr0: u64,
    pub cr2: u64,
    pub cr3: u64,
    pub cr4: u64,
    pub dr0: u64,
    pub dr1: u64,
    pub dr2: u64,
    pub dr3: u64,
    pub dr6: u64,
    pub dr7: u64,
    pub cs_sel: u32,
    pub ds_sel: u32,
    pub es_sel: u32,
    pub fs_sel: u32,
    pub gs_sel: u32,
    pub ss_sel: u32,
    pub tr_sel: u32,
    pub ldtr_sel: u32,
    pub cs_limit: u32,
    pub ds_limit: u32,
    pub es_limit: u32,
    pub fs_limit: u32,
    pub gs_limit: u32,
    pub ss_limit: u32,
    pub tr_limit: u32,
    pub ldtr_limit: u32,
    pub idtr_limit: u32,
    pub gdtr_limit: u32,
    pub cs_base: u64,
    pub ds_base: u64,
    pub es_base: u64,
    pub fs_base: u64,
    pub gs_base: u64,
    pub ss_base: u64,
    pub tr_base: u64,
    pub ldtr_base: u64,
    pub idtr_base: u64,
    pub gdtr_base: u64,
    pub cs_arbytes: u32,
    pub ds_arbytes: u32,
    pub es_arbytes: u32,
    pub fs_arbytes: u32,
    pub gs_arbytes: u32,
    pub ss_arbytes: u32,
    pub tr_arbytes: u32,
    pub ldtr_arbytes: u32,
    pub sysenter_cs: u64,
    pub sysenter_esp: u64,
    pub sysenter_eip: u64,
    pub shadow_gs: u64,
    pub msr_flags: u64,
    pub msr_lstar: u64,
    pub msr_star: u64,
    pub msr_cstar: u64,
    pub msr_syscall_mask: u64,
    pub msr_efer: u64,
    pub msr_tsc_aux: u64,
    pub tsc: u64,
    pub __bindgen_anon_1: hvm_hw_cpu__bindgen_ty_1,
    pub error_code: u32,
    pub flags: u32,
    pub pad0: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hvm_hw_cpu__bindgen_ty_1 {
    pub pending_event: u32,
    pub __bindgen_anon_1: hvm_hw_cpu__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_cpu__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl hvm_hw_cpu__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn pending_vector(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_pending_vector(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pending_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pending_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pending_error_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pending_error_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pending_reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_pending_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn pending_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pending_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pending_vector: u8,
        pending_type: u8,
        pending_error_valid: u8,
        pending_reserved: u32,
        pending_valid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let pending_vector: u8 = unsafe { ::core::mem::transmute(pending_vector) };
            pending_vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let pending_type: u8 = unsafe { ::core::mem::transmute(pending_type) };
            pending_type as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let pending_error_valid: u8 = unsafe { ::core::mem::transmute(pending_error_valid) };
            pending_error_valid as u64
        });
        __bindgen_bitfield_unit.set(12usize, 19u8, {
            let pending_reserved: u32 = unsafe { ::core::mem::transmute(pending_reserved) };
            pending_reserved as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let pending_valid: u8 = unsafe { ::core::mem::transmute(pending_valid) };
            pending_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hvm_hw_cpu_compat {
    pub fpu_regs: [u8; 512usize],
    pub rax: u64,
    pub rbx: u64,
    pub rcx: u64,
    pub rdx: u64,
    pub rbp: u64,
    pub rsi: u64,
    pub rdi: u64,
    pub rsp: u64,
    pub r8: u64,
    pub r9: u64,
    pub r10: u64,
    pub r11: u64,
    pub r12: u64,
    pub r13: u64,
    pub r14: u64,
    pub r15: u64,
    pub rip: u64,
    pub rflags: u64,
    pub cr0: u64,
    pub cr2: u64,
    pub cr3: u64,
    pub cr4: u64,
    pub dr0: u64,
    pub dr1: u64,
    pub dr2: u64,
    pub dr3: u64,
    pub dr6: u64,
    pub dr7: u64,
    pub cs_sel: u32,
    pub ds_sel: u32,
    pub es_sel: u32,
    pub fs_sel: u32,
    pub gs_sel: u32,
    pub ss_sel: u32,
    pub tr_sel: u32,
    pub ldtr_sel: u32,
    pub cs_limit: u32,
    pub ds_limit: u32,
    pub es_limit: u32,
    pub fs_limit: u32,
    pub gs_limit: u32,
    pub ss_limit: u32,
    pub tr_limit: u32,
    pub ldtr_limit: u32,
    pub idtr_limit: u32,
    pub gdtr_limit: u32,
    pub cs_base: u64,
    pub ds_base: u64,
    pub es_base: u64,
    pub fs_base: u64,
    pub gs_base: u64,
    pub ss_base: u64,
    pub tr_base: u64,
    pub ldtr_base: u64,
    pub idtr_base: u64,
    pub gdtr_base: u64,
    pub cs_arbytes: u32,
    pub ds_arbytes: u32,
    pub es_arbytes: u32,
    pub fs_arbytes: u32,
    pub gs_arbytes: u32,
    pub ss_arbytes: u32,
    pub tr_arbytes: u32,
    pub ldtr_arbytes: u32,
    pub sysenter_cs: u64,
    pub sysenter_esp: u64,
    pub sysenter_eip: u64,
    pub shadow_gs: u64,
    pub msr_flags: u64,
    pub msr_lstar: u64,
    pub msr_star: u64,
    pub msr_cstar: u64,
    pub msr_syscall_mask: u64,
    pub msr_efer: u64,
    pub tsc: u64,
    pub __bindgen_anon_1: hvm_hw_cpu_compat__bindgen_ty_1,
    pub error_code: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hvm_hw_cpu_compat__bindgen_ty_1 {
    pub pending_event: u32,
    pub __bindgen_anon_1: hvm_hw_cpu_compat__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_cpu_compat__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl hvm_hw_cpu_compat__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn pending_vector(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_pending_vector(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pending_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pending_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pending_error_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pending_error_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pending_reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_pending_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn pending_valid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pending_valid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pending_vector: u8,
        pending_type: u8,
        pending_error_valid: u8,
        pending_reserved: u32,
        pending_valid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let pending_vector: u8 = unsafe { ::core::mem::transmute(pending_vector) };
            pending_vector as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let pending_type: u8 = unsafe { ::core::mem::transmute(pending_type) };
            pending_type as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let pending_error_valid: u8 = unsafe { ::core::mem::transmute(pending_error_valid) };
            pending_error_valid as u64
        });
        __bindgen_bitfield_unit.set(12usize, 19u8, {
            let pending_reserved: u32 = unsafe { ::core::mem::transmute(pending_reserved) };
            pending_reserved as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let pending_valid: u8 = unsafe { ::core::mem::transmute(pending_valid) };
            pending_valid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __HVM_SAVE_TYPE_CPU {
    pub t: hvm_hw_cpu,
    pub c: [xen_bindings_x86_64_types::c_char; 2usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_vpic {
    pub irr: u8,
    pub imr: u8,
    pub isr: u8,
    pub irq_base: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub elcr: u8,
    pub int_output: u8,
}
impl hvm_hw_vpic {
    #[inline]
    pub fn init_state(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_init_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn priority_add(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_priority_add(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn readsel_isr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_readsel_isr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn poll(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_poll(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_eoi(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_eoi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rotate_on_auto_eoi(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rotate_on_auto_eoi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn special_fully_nested_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_special_fully_nested_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn special_mask_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_special_mask_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_master(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_master(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        init_state: u8,
        priority_add: u8,
        readsel_isr: u8,
        poll: u8,
        auto_eoi: u8,
        rotate_on_auto_eoi: u8,
        special_fully_nested_mode: u8,
        special_mask_mode: u8,
        is_master: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let init_state: u8 = unsafe { ::core::mem::transmute(init_state) };
            init_state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let priority_add: u8 = unsafe { ::core::mem::transmute(priority_add) };
            priority_add as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let readsel_isr: u8 = unsafe { ::core::mem::transmute(readsel_isr) };
            readsel_isr as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let poll: u8 = unsafe { ::core::mem::transmute(poll) };
            poll as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let auto_eoi: u8 = unsafe { ::core::mem::transmute(auto_eoi) };
            auto_eoi as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let rotate_on_auto_eoi: u8 = unsafe { ::core::mem::transmute(rotate_on_auto_eoi) };
            rotate_on_auto_eoi as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let special_fully_nested_mode: u8 =
                unsafe { ::core::mem::transmute(special_fully_nested_mode) };
            special_fully_nested_mode as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let special_mask_mode: u8 = unsafe { ::core::mem::transmute(special_mask_mode) };
            special_mask_mode as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let is_master: u8 = unsafe { ::core::mem::transmute(is_master) };
            is_master as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_PIC {
    pub t: hvm_hw_vpic,
    pub c: [xen_bindings_x86_64_types::c_char; 3usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vioapic_redir_entry {
    pub bits: u64,
    pub fields: vioapic_redir_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vioapic_redir_entry__bindgen_ty_1 {
    pub vector: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub reserved: [u8; 4usize],
    pub dest_id: u8,
}
impl vioapic_redir_entry__bindgen_ty_1 {
    #[inline]
    pub fn delivery_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_delivery_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dest_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dest_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivery_status(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_delivery_status(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn polarity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_polarity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remote_irr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remote_irr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trig_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_trig_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserve(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserve(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        delivery_mode: u8,
        dest_mode: u8,
        delivery_status: u8,
        polarity: u8,
        remote_irr: u8,
        trig_mode: u8,
        mask: u8,
        reserve: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let delivery_mode: u8 = unsafe { ::core::mem::transmute(delivery_mode) };
            delivery_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dest_mode: u8 = unsafe { ::core::mem::transmute(dest_mode) };
            dest_mode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let delivery_status: u8 = unsafe { ::core::mem::transmute(delivery_status) };
            delivery_status as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let polarity: u8 = unsafe { ::core::mem::transmute(polarity) };
            polarity as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let remote_irr: u8 = unsafe { ::core::mem::transmute(remote_irr) };
            remote_irr as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let trig_mode: u8 = unsafe { ::core::mem::transmute(trig_mode) };
            trig_mode as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mask: u8 = unsafe { ::core::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let reserve: u8 = unsafe { ::core::mem::transmute(reserve) };
            reserve as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hvm_hw_vioapic {
    pub base_address: u64,
    pub ioregsel: u32,
    pub id: u32,
    pub redirtbl: [vioapic_redir_entry; 48usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __HVM_SAVE_TYPE_IOAPIC {
    pub t: hvm_hw_vioapic,
    pub c: [xen_bindings_x86_64_types::c_char; 4usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_lapic {
    pub apic_base_msr: u64,
    pub disabled: u32,
    pub timer_divisor: u32,
    pub tdt_msr: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_LAPIC {
    pub t: hvm_hw_lapic,
    pub c: [xen_bindings_x86_64_types::c_char; 5usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_lapic_regs {
    pub data: [u8; 1024usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_LAPIC_REGS {
    pub t: hvm_hw_lapic_regs,
    pub c: [xen_bindings_x86_64_types::c_char; 6usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hvm_hw_pci_irqs {
    pub __bindgen_anon_1: hvm_hw_pci_irqs__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hvm_hw_pci_irqs__bindgen_ty_1 {
    pub i: [xen_bindings_x86_64_types::c_ulong; 2usize],
    pub pad: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __HVM_SAVE_TYPE_PCI_IRQ {
    pub t: hvm_hw_pci_irqs,
    pub c: [xen_bindings_x86_64_types::c_char; 7usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hvm_hw_isa_irqs {
    pub __bindgen_anon_1: hvm_hw_isa_irqs__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hvm_hw_isa_irqs__bindgen_ty_1 {
    pub i: [xen_bindings_x86_64_types::c_ulong; 1usize],
    pub pad: [u64; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __HVM_SAVE_TYPE_ISA_IRQ {
    pub t: hvm_hw_isa_irqs,
    pub c: [xen_bindings_x86_64_types::c_char; 8usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_pci_link {
    pub route: [u8; 4usize],
    pub pad0: [u8; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_PCI_LINK {
    pub t: hvm_hw_pci_link,
    pub c: [xen_bindings_x86_64_types::c_char; 9usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_pit {
    pub channels: [hvm_hw_pit_hvm_hw_pit_channel; 3usize],
    pub speaker_data_on: u32,
    pub pad0: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_pit_hvm_hw_pit_channel {
    pub count: u32,
    pub latched_count: u16,
    pub count_latched: u8,
    pub status_latched: u8,
    pub status: u8,
    pub read_state: u8,
    pub write_state: u8,
    pub write_latch: u8,
    pub rw_mode: u8,
    pub mode: u8,
    pub bcd: u8,
    pub gate: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_PIT {
    pub t: hvm_hw_pit,
    pub c: [xen_bindings_x86_64_types::c_char; 10usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_rtc {
    pub cmos_data: [u8; 14usize],
    pub cmos_index: u8,
    pub pad0: u8,
    pub rtc_offset: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_RTC {
    pub t: hvm_hw_rtc,
    pub c: [xen_bindings_x86_64_types::c_char; 11usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_hpet {
    pub capability: u64,
    pub res0: u64,
    pub config: u64,
    pub res1: u64,
    pub isr: u64,
    pub res2: [u64; 25usize],
    pub mc64: u64,
    pub res3: u64,
    pub timers: [hvm_hw_hpet__bindgen_ty_1; 3usize],
    pub res5: [u64; 84usize],
    pub period: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_hpet__bindgen_ty_1 {
    pub config: u64,
    pub cmp: u64,
    pub fsb: u64,
    pub res4: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_HPET {
    pub t: hvm_hw_hpet,
    pub c: [xen_bindings_x86_64_types::c_char; 12usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_pmtimer {
    pub tmr_val: u32,
    pub pm1a_sts: u16,
    pub pm1a_en: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_PMTIMER {
    pub t: hvm_hw_pmtimer,
    pub c: [xen_bindings_x86_64_types::c_char; 13usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_mtrr {
    pub msr_pat_cr: u64,
    pub msr_mtrr_var: [u64; 16usize],
    pub msr_mtrr_fixed: [u64; 11usize],
    pub msr_mtrr_cap: u64,
    pub msr_mtrr_def_type: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_MTRR {
    pub t: hvm_hw_mtrr,
    pub c: [xen_bindings_x86_64_types::c_char; 14usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_cpu_xsave {
    pub xfeature_mask: u64,
    pub xcr0: u64,
    pub xcr0_accum: u64,
    pub save_area: hvm_hw_cpu_xsave__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_cpu_xsave__bindgen_ty_1 {
    pub fpu_sse: hvm_hw_cpu_xsave__bindgen_ty_1__bindgen_ty_1,
    pub xsave_hdr: hvm_hw_cpu_xsave__bindgen_ty_1_hvm_hw_cpu_xsave_hdr,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_cpu_xsave__bindgen_ty_1__bindgen_ty_1 {
    pub x: [xen_bindings_x86_64_types::c_char; 512usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_hw_cpu_xsave__bindgen_ty_1_hvm_hw_cpu_xsave_hdr {
    pub xstate_bv: u64,
    pub xcomp_bv: u64,
    pub reserved: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_viridian_domain_context {
    pub hypercall_gpa: u64,
    pub guest_os_id: u64,
    pub time_ref_count: u64,
    pub reference_tsc: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_VIRIDIAN_DOMAIN {
    pub t: hvm_viridian_domain_context,
    pub c: [xen_bindings_x86_64_types::c_char; 15usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_viridian_vcpu_context {
    pub vp_assist_msr: u64,
    pub apic_assist_pending: u8,
    pub _pad: [u8; 7usize],
    pub simp_msr: u64,
    pub sint_msr: [u64; 16usize],
    pub stimer_config_msr: [u64; 4usize],
    pub stimer_count_msr: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_VIRIDIAN_VCPU {
    pub t: hvm_viridian_vcpu_context,
    pub c: [xen_bindings_x86_64_types::c_char; 17usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_vmce_vcpu {
    pub caps: u64,
    pub mci_ctl2_bank0: u64,
    pub mci_ctl2_bank1: u64,
    pub mcg_ext_ctl: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_VMCE_VCPU {
    pub t: hvm_vmce_vcpu,
    pub c: [xen_bindings_x86_64_types::c_char; 18usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_tsc_adjust {
    pub tsc_adjust: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __HVM_SAVE_TYPE_TSC_ADJUST {
    pub t: hvm_tsc_adjust,
    pub c: [xen_bindings_x86_64_types::c_char; 19usize],
    pub cpt: [xen_bindings_x86_64_types::c_char; 1usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct hvm_msr {
    pub count: u32,
    pub msr: __IncompleteArrayField<hvm_msr_hvm_one_msr>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hvm_msr_hvm_one_msr {
    pub index: u32,
    pub _rsvd: u32,
    pub val: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_eoi {
    pub irq: u32,
}
pub type physdev_eoi_t = physdev_eoi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_eoi_t {
    pub p: *mut physdev_eoi_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_eoi_t {
    pub p: *const physdev_eoi_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_pirq_eoi_gmfn {
    pub gmfn: xen_pfn_t,
}
pub type physdev_pirq_eoi_gmfn_t = physdev_pirq_eoi_gmfn;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_pirq_eoi_gmfn_t {
    pub p: *mut physdev_pirq_eoi_gmfn_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_pirq_eoi_gmfn_t {
    pub p: *const physdev_pirq_eoi_gmfn_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_irq_status_query {
    pub irq: u32,
    pub flags: u32,
}
pub type physdev_irq_status_query_t = physdev_irq_status_query;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_irq_status_query_t {
    pub p: *mut physdev_irq_status_query_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_irq_status_query_t {
    pub p: *const physdev_irq_status_query_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_set_iopl {
    pub iopl: u32,
}
pub type physdev_set_iopl_t = physdev_set_iopl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_set_iopl_t {
    pub p: *mut physdev_set_iopl_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_set_iopl_t {
    pub p: *const physdev_set_iopl_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_set_iobitmap {
    pub bitmap: __guest_handle_uint8,
    pub nr_ports: u32,
}
pub type physdev_set_iobitmap_t = physdev_set_iobitmap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_set_iobitmap_t {
    pub p: *mut physdev_set_iobitmap_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_set_iobitmap_t {
    pub p: *const physdev_set_iobitmap_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_apic {
    pub apic_physbase: xen_bindings_x86_64_types::c_ulong,
    pub reg: u32,
    pub value: u32,
}
pub type physdev_apic_t = physdev_apic;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_apic_t {
    pub p: *mut physdev_apic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_apic_t {
    pub p: *const physdev_apic_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_irq {
    pub irq: u32,
    pub vector: u32,
}
pub type physdev_irq_t = physdev_irq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_irq_t {
    pub p: *mut physdev_irq_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_irq_t {
    pub p: *const physdev_irq_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_map_pirq {
    pub domid: domid_t,
    pub type_: xen_bindings_x86_64_types::c_int,
    pub index: xen_bindings_x86_64_types::c_int,
    pub pirq: xen_bindings_x86_64_types::c_int,
    pub bus: xen_bindings_x86_64_types::c_int,
    pub devfn: xen_bindings_x86_64_types::c_int,
    pub entry_nr: xen_bindings_x86_64_types::c_int,
    pub table_base: u64,
}
pub type physdev_map_pirq_t = physdev_map_pirq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_map_pirq_t {
    pub p: *mut physdev_map_pirq_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_map_pirq_t {
    pub p: *const physdev_map_pirq_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_unmap_pirq {
    pub domid: domid_t,
    pub pirq: xen_bindings_x86_64_types::c_int,
}
pub type physdev_unmap_pirq_t = physdev_unmap_pirq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_unmap_pirq_t {
    pub p: *mut physdev_unmap_pirq_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_unmap_pirq_t {
    pub p: *const physdev_unmap_pirq_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_manage_pci {
    pub bus: u8,
    pub devfn: u8,
}
pub type physdev_manage_pci_t = physdev_manage_pci;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_manage_pci_t {
    pub p: *mut physdev_manage_pci_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_manage_pci_t {
    pub p: *const physdev_manage_pci_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_restore_msi {
    pub bus: u8,
    pub devfn: u8,
}
pub type physdev_restore_msi_t = physdev_restore_msi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_restore_msi_t {
    pub p: *mut physdev_restore_msi_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_restore_msi_t {
    pub p: *const physdev_restore_msi_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_manage_pci_ext {
    pub bus: u8,
    pub devfn: u8,
    pub is_extfn: u32,
    pub is_virtfn: u32,
    pub physfn: physdev_manage_pci_ext__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_manage_pci_ext__bindgen_ty_1 {
    pub bus: u8,
    pub devfn: u8,
}
pub type physdev_manage_pci_ext_t = physdev_manage_pci_ext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_manage_pci_ext_t {
    pub p: *mut physdev_manage_pci_ext_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_manage_pci_ext_t {
    pub p: *const physdev_manage_pci_ext_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct physdev_op {
    pub cmd: u32,
    pub u: physdev_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union physdev_op__bindgen_ty_1 {
    pub irq_status_query: physdev_irq_status_query_t,
    pub set_iopl: physdev_set_iopl_t,
    pub set_iobitmap: physdev_set_iobitmap_t,
    pub apic_op: physdev_apic_t,
    pub irq_op: physdev_irq_t,
}
pub type physdev_op_t = physdev_op;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_op_t {
    pub p: *mut physdev_op_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_op_t {
    pub p: *const physdev_op_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_setup_gsi {
    pub gsi: xen_bindings_x86_64_types::c_int,
    pub triggering: u8,
    pub polarity: u8,
}
pub type physdev_setup_gsi_t = physdev_setup_gsi;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_setup_gsi_t {
    pub p: *mut physdev_setup_gsi_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_setup_gsi_t {
    pub p: *const physdev_setup_gsi_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_get_free_pirq {
    pub type_: xen_bindings_x86_64_types::c_int,
    pub pirq: u32,
}
pub type physdev_get_free_pirq_t = physdev_get_free_pirq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_get_free_pirq_t {
    pub p: *mut physdev_get_free_pirq_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_get_free_pirq_t {
    pub p: *const physdev_get_free_pirq_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_pci_mmcfg_reserved {
    pub address: u64,
    pub segment: u16,
    pub start_bus: u8,
    pub end_bus: u8,
    pub flags: u32,
}
pub type physdev_pci_mmcfg_reserved_t = physdev_pci_mmcfg_reserved;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_pci_mmcfg_reserved_t {
    pub p: *mut physdev_pci_mmcfg_reserved_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_pci_mmcfg_reserved_t {
    pub p: *const physdev_pci_mmcfg_reserved_t,
}
#[repr(C)]
#[derive(Debug)]
pub struct physdev_pci_device_add {
    pub seg: u16,
    pub bus: u8,
    pub devfn: u8,
    pub flags: u32,
    pub physfn: physdev_pci_device_add__bindgen_ty_1,
    pub optarr: __IncompleteArrayField<u32>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_pci_device_add__bindgen_ty_1 {
    pub bus: u8,
    pub devfn: u8,
}
pub type physdev_pci_device_add_t = physdev_pci_device_add;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_pci_device_add_t {
    pub p: *mut physdev_pci_device_add_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_pci_device_add_t {
    pub p: *const physdev_pci_device_add_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct physdev_pci_device {
    pub seg: u16,
    pub bus: u8,
    pub devfn: u8,
}
pub type physdev_pci_device_t = physdev_pci_device;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_pci_device_t {
    pub p: *mut physdev_pci_device_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_pci_device_t {
    pub p: *const physdev_pci_device_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct physdev_dbgp_op {
    pub op: u8,
    pub bus: u8,
    pub u: physdev_dbgp_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union physdev_dbgp_op__bindgen_ty_1 {
    pub pci: physdev_pci_device_t,
}
pub type physdev_dbgp_op_t = physdev_dbgp_op;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_physdev_dbgp_op_t {
    pub p: *mut physdev_dbgp_op_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_physdev_dbgp_op_t {
    pub p: *const physdev_dbgp_op_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_memory_reservation {
    pub extent_start: __guest_handle_xen_pfn_t,
    pub nr_extents: xen_ulong_t,
    pub extent_order: xen_bindings_x86_64_types::c_uint,
    pub mem_flags: xen_bindings_x86_64_types::c_uint,
    pub domid: domid_t,
}
pub type xen_memory_reservation_t = xen_memory_reservation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_memory_reservation_t {
    pub p: *mut xen_memory_reservation_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_memory_reservation_t {
    pub p: *const xen_memory_reservation_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_memory_exchange {
    pub in_: xen_memory_reservation,
    pub out: xen_memory_reservation,
    pub nr_exchanged: xen_ulong_t,
}
pub type xen_memory_exchange_t = xen_memory_exchange;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_memory_exchange_t {
    pub p: *mut xen_memory_exchange_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_memory_exchange_t {
    pub p: *const xen_memory_exchange_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_memory_domain {
    pub domid: domid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_machphys_mfn_list {
    pub max_extents: xen_bindings_x86_64_types::c_uint,
    pub extent_start: __guest_handle_xen_pfn_t,
    pub nr_extents: xen_bindings_x86_64_types::c_uint,
}
pub type xen_machphys_mfn_list_t = xen_machphys_mfn_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_machphys_mfn_list_t {
    pub p: *mut xen_machphys_mfn_list_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_machphys_mfn_list_t {
    pub p: *const xen_machphys_mfn_list_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_machphys_mapping {
    pub v_start: xen_ulong_t,
    pub v_end: xen_ulong_t,
    pub max_mfn: xen_ulong_t,
}
pub type xen_machphys_mapping_t = xen_machphys_mapping;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_machphys_mapping_t {
    pub p: *mut xen_machphys_mapping_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_machphys_mapping_t {
    pub p: *const xen_machphys_mapping_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_add_to_physmap {
    pub domid: domid_t,
    pub size: u16,
    pub space: xen_bindings_x86_64_types::c_uint,
    pub idx: xen_ulong_t,
    pub gpfn: xen_pfn_t,
}
pub type xen_add_to_physmap_t = xen_add_to_physmap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_add_to_physmap_t {
    pub p: *mut xen_add_to_physmap_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_add_to_physmap_t {
    pub p: *const xen_add_to_physmap_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_add_to_physmap_batch {
    pub domid: domid_t,
    pub space: u16,
    pub size: u16,
    pub u: xen_add_to_physmap_batch_xen_add_to_physmap_batch_extra,
    pub idxs: __guest_handle_xen_ulong_t,
    pub gpfns: __guest_handle_xen_pfn_t,
    pub errs: __guest_handle_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_add_to_physmap_batch_xen_add_to_physmap_batch_extra {
    pub foreign_domid: domid_t,
    pub res0: u16,
}
pub type xen_add_to_physmap_batch_t = xen_add_to_physmap_batch;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_add_to_physmap_batch_t {
    pub p: *mut xen_add_to_physmap_batch_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_add_to_physmap_batch_t {
    pub p: *const xen_add_to_physmap_batch_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_remove_from_physmap {
    pub domid: domid_t,
    pub gpfn: xen_pfn_t,
}
pub type xen_remove_from_physmap_t = xen_remove_from_physmap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_remove_from_physmap_t {
    pub p: *mut xen_remove_from_physmap_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_remove_from_physmap_t {
    pub p: *const xen_remove_from_physmap_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_memory_map {
    pub nr_entries: xen_bindings_x86_64_types::c_uint,
    pub buffer: __guest_handle_void,
}
pub type xen_memory_map_t = xen_memory_map;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_memory_map_t {
    pub p: *mut xen_memory_map_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_memory_map_t {
    pub p: *const xen_memory_map_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_foreign_memory_map {
    pub domid: domid_t,
    pub map: xen_memory_map,
}
pub type xen_foreign_memory_map_t = xen_foreign_memory_map;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_foreign_memory_map_t {
    pub p: *mut xen_foreign_memory_map_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_foreign_memory_map_t {
    pub p: *const xen_foreign_memory_map_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_pod_target {
    pub target_pages: u64,
    pub tot_pages: u64,
    pub pod_cache_pages: u64,
    pub pod_entries: u64,
    pub domid: domid_t,
}
pub type xen_pod_target_t = xen_pod_target;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_mem_paging_op {
    pub op: u8,
    pub domain: domid_t,
    pub buffer: __guest_handle_const_uint8,
    pub gfn: u64,
}
pub type xen_mem_paging_op_t = xen_mem_paging_op;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_mem_paging_op_t {
    pub p: *mut xen_mem_paging_op_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_mem_paging_op_t {
    pub p: *const xen_mem_paging_op_t,
}
pub const xenmem_access_t_XENMEM_access_n: xenmem_access_t = 0;
pub const xenmem_access_t_XENMEM_access_r: xenmem_access_t = 1;
pub const xenmem_access_t_XENMEM_access_w: xenmem_access_t = 2;
pub const xenmem_access_t_XENMEM_access_rw: xenmem_access_t = 3;
pub const xenmem_access_t_XENMEM_access_x: xenmem_access_t = 4;
pub const xenmem_access_t_XENMEM_access_rx: xenmem_access_t = 5;
pub const xenmem_access_t_XENMEM_access_wx: xenmem_access_t = 6;
pub const xenmem_access_t_XENMEM_access_rwx: xenmem_access_t = 7;
pub const xenmem_access_t_XENMEM_access_rx2rw: xenmem_access_t = 8;
pub const xenmem_access_t_XENMEM_access_n2rwx: xenmem_access_t = 9;
pub const xenmem_access_t_XENMEM_access_default: xenmem_access_t = 10;
pub type xenmem_access_t = xen_bindings_x86_64_types::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_mem_access_op {
    pub op: u8,
    pub access: u8,
    pub domid: domid_t,
    pub nr: u32,
    pub pfn: u64,
    pub pfn_list: __guest_handle_const_uint64,
    pub access_list: __guest_handle_const_uint8,
}
pub type xen_mem_access_op_t = xen_mem_access_op;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_mem_access_op_t {
    pub p: *mut xen_mem_access_op_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_mem_access_op_t {
    pub p: *const xen_mem_access_op_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_mem_sharing_op {
    pub op: u8,
    pub domain: domid_t,
    pub u: xen_mem_sharing_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_mem_sharing_op__bindgen_ty_1 {
    pub nominate: xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_nominate,
    pub share: xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_share,
    pub range: xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_range,
    pub debug: xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_debug,
    pub fork: xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_fork,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_nominate {
    pub u: xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_nominate__bindgen_ty_1,
    pub handle: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_nominate__bindgen_ty_1 {
    pub gfn: u64,
    pub grant_ref: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_share {
    pub source_gfn: u64,
    pub source_handle: u64,
    pub client_gfn: u64,
    pub client_handle: u64,
    pub client_domain: domid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_range {
    pub first_gfn: u64,
    pub last_gfn: u64,
    pub opaque: u64,
    pub client_domain: domid_t,
    pub _pad: [u16; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_debug {
    pub u: xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_debug__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_debug__bindgen_ty_1 {
    pub gfn: u64,
    pub mfn: u64,
    pub gref: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_mem_sharing_op__bindgen_ty_1_mem_sharing_op_fork {
    pub parent_domain: domid_t,
    pub flags: u16,
    pub pad: u32,
}
pub type xen_mem_sharing_op_t = xen_mem_sharing_op;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_mem_sharing_op_t {
    pub p: *mut xen_mem_sharing_op_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_mem_sharing_op_t {
    pub p: *const xen_mem_sharing_op_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_reserved_device_memory {
    pub start_pfn: xen_pfn_t,
    pub nr_pages: xen_ulong_t,
}
pub type xen_reserved_device_memory_t = xen_reserved_device_memory;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_reserved_device_memory_t {
    pub p: *mut xen_reserved_device_memory_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_reserved_device_memory_t {
    pub p: *const xen_reserved_device_memory_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_reserved_device_memory_map {
    pub flags: u32,
    pub nr_entries: xen_bindings_x86_64_types::c_uint,
    pub buffer: __guest_handle_xen_reserved_device_memory_t,
    pub dev: xen_reserved_device_memory_map__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_reserved_device_memory_map__bindgen_ty_1 {
    pub pci: physdev_pci_device_t,
}
pub type xen_reserved_device_memory_map_t = xen_reserved_device_memory_map;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_reserved_device_memory_map_t {
    pub p: *mut xen_reserved_device_memory_map_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_reserved_device_memory_map_t {
    pub p: *const xen_reserved_device_memory_map_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_mem_acquire_resource {
    pub domid: domid_t,
    pub type_: u16,
    pub id: u32,
    pub nr_frames: u32,
    pub pad: u32,
    pub frame: u64,
    pub frame_list: __guest_handle_xen_pfn_t,
}
pub type xen_mem_acquire_resource_t = xen_mem_acquire_resource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_mem_acquire_resource_t {
    pub p: *mut xen_mem_acquire_resource_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_mem_acquire_resource_t {
    pub p: *const xen_mem_acquire_resource_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_vmemrange {
    pub start: u64,
    pub end: u64,
    pub flags: xen_bindings_x86_64_types::c_uint,
    pub nid: xen_bindings_x86_64_types::c_uint,
}
pub type xen_vmemrange_t = xen_vmemrange;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_vmemrange_t {
    pub p: *mut xen_vmemrange_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_vmemrange_t {
    pub p: *const xen_vmemrange_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_vnuma_topology_info {
    pub domid: domid_t,
    pub pad: u16,
    pub nr_vnodes: xen_bindings_x86_64_types::c_uint,
    pub nr_vcpus: xen_bindings_x86_64_types::c_uint,
    pub nr_vmemranges: xen_bindings_x86_64_types::c_uint,
    pub vdistance: xen_vnuma_topology_info__bindgen_ty_1,
    pub vcpu_to_vnode: xen_vnuma_topology_info__bindgen_ty_2,
    pub vmemrange: xen_vnuma_topology_info__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_vnuma_topology_info__bindgen_ty_1 {
    pub h: __guest_handle_uint,
    pub pad: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_vnuma_topology_info__bindgen_ty_2 {
    pub h: __guest_handle_uint,
    pub pad: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_vnuma_topology_info__bindgen_ty_3 {
    pub h: __guest_handle_xen_vmemrange_t,
    pub pad: u64,
}
pub type xen_vnuma_topology_info_t = xen_vnuma_topology_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_vnuma_topology_info_t {
    pub p: *mut xen_vnuma_topology_info_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_vnuma_topology_info_t {
    pub p: *const xen_vnuma_topology_info_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_createdomain {
    pub ssidref: u32,
    pub handle: xen_domain_handle_t,
    pub flags: u32,
    pub iommu_opts: u32,
    pub max_vcpus: u32,
    pub max_evtchn_port: u32,
    pub max_grant_frames: i32,
    pub max_maptrack_frames: i32,
    pub grant_opts: u32,
    pub vmtrace_size: u32,
    pub cpupool_id: u32,
    pub arch: xen_arch_domainconfig,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_getdomaininfo {
    pub domain: domid_t,
    pub pad1: u16,
    pub flags: u32,
    pub tot_pages: u64,
    pub max_pages: u64,
    pub outstanding_pages: u64,
    pub shr_pages: u64,
    pub paged_pages: u64,
    pub shared_info_frame: u64,
    pub cpu_time: u64,
    pub nr_online_vcpus: u32,
    pub max_vcpu_id: u32,
    pub ssidref: u32,
    pub handle: xen_domain_handle_t,
    pub cpupool: u32,
    pub gpaddr_bits: u8,
    pub pad2: [u8; 7usize],
    pub arch_config: xen_arch_domainconfig,
}
pub type xen_domctl_getdomaininfo_t = xen_domctl_getdomaininfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_domctl_getdomaininfo_t {
    pub p: *mut xen_domctl_getdomaininfo_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_domctl_getdomaininfo_t {
    pub p: *const xen_domctl_getdomaininfo_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_getpageframeinfo3 {
    pub num: u64,
    pub array: __guest_handle_xen_pfn_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_shadow_op_stats {
    pub fault_count: u32,
    pub dirty_count: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_shadow_op {
    pub op: u32,
    pub mode: u32,
    pub mb: u32,
    pub dirty_bitmap: __guest_handle_uint8,
    pub pages: u64,
    pub stats: xen_domctl_shadow_op_stats,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_max_mem {
    pub max_memkb: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_vcpucontext {
    pub vcpu: u32,
    pub ctxt: __guest_handle_vcpu_guest_context_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_getvcpuinfo {
    pub vcpu: u32,
    pub online: u8,
    pub blocked: u8,
    pub running: u8,
    pub cpu_time: u64,
    pub cpu: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_nodeaffinity {
    pub nodemap: xenctl_bitmap,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_vcpuaffinity {
    pub vcpu: u32,
    pub flags: u32,
    pub cpumap_hard: xenctl_bitmap,
    pub cpumap_soft: xenctl_bitmap,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_max_vcpus {
    pub max: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_sched_credit {
    pub weight: u16,
    pub cap: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_sched_credit2 {
    pub weight: u16,
    pub cap: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_sched_rtds {
    pub period: u32,
    pub budget: u32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_domctl_schedparam_vcpu {
    pub u: xen_domctl_schedparam_vcpu__bindgen_ty_1,
    pub vcpuid: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_domctl_schedparam_vcpu__bindgen_ty_1 {
    pub credit: xen_domctl_sched_credit,
    pub credit2: xen_domctl_sched_credit2,
    pub rtds: xen_domctl_sched_rtds,
}
pub type xen_domctl_schedparam_vcpu_t = xen_domctl_schedparam_vcpu;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_domctl_schedparam_vcpu_t {
    pub p: *mut xen_domctl_schedparam_vcpu_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_domctl_schedparam_vcpu_t {
    pub p: *const xen_domctl_schedparam_vcpu_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_domctl_scheduler_op {
    pub sched_id: u32,
    pub cmd: u32,
    pub u: xen_domctl_scheduler_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_domctl_scheduler_op__bindgen_ty_1 {
    pub credit: xen_domctl_sched_credit,
    pub credit2: xen_domctl_sched_credit2,
    pub rtds: xen_domctl_sched_rtds,
    pub v: xen_domctl_scheduler_op__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_scheduler_op__bindgen_ty_1__bindgen_ty_1 {
    pub vcpus: __guest_handle_xen_domctl_schedparam_vcpu_t,
    pub nr_vcpus: u32,
    pub padding: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_setdomainhandle {
    pub handle: xen_domain_handle_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_setdebugging {
    pub enable: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_irq_permission {
    pub pirq: u32,
    pub allow_access: u8,
    pub pad: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_iomem_permission {
    pub first_mfn: u64,
    pub nr_mfns: u64,
    pub allow_access: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_ioport_permission {
    pub first_port: u32,
    pub nr_ports: u32,
    pub allow_access: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_hypercall_init {
    pub gmfn: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_settimeoffset {
    pub time_offset_seconds: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_hvmcontext {
    pub size: u32,
    pub buffer: __guest_handle_uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_address_size {
    pub size: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_sendtrigger {
    pub trigger: u32,
    pub vcpu: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_domctl_assign_device {
    pub dev: u32,
    pub flags: u32,
    pub u: xen_domctl_assign_device__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_domctl_assign_device__bindgen_ty_1 {
    pub pci: xen_domctl_assign_device__bindgen_ty_1__bindgen_ty_1,
    pub dt: xen_domctl_assign_device__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_assign_device__bindgen_ty_1__bindgen_ty_1 {
    pub machine_sbdf: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_assign_device__bindgen_ty_1__bindgen_ty_2 {
    pub size: u32,
    pub path: __guest_handle_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_get_device_group {
    pub machine_sbdf: u32,
    pub max_sdevs: u32,
    pub num_sdevs: u32,
    pub sdev_array: __guest_handle_uint32,
}
pub const pt_irq_type_PT_IRQ_TYPE_PCI: pt_irq_type = 0;
pub const pt_irq_type_PT_IRQ_TYPE_ISA: pt_irq_type = 1;
pub const pt_irq_type_PT_IRQ_TYPE_MSI: pt_irq_type = 2;
pub const pt_irq_type_PT_IRQ_TYPE_MSI_TRANSLATE: pt_irq_type = 3;
pub const pt_irq_type_PT_IRQ_TYPE_SPI: pt_irq_type = 4;
pub type pt_irq_type = xen_bindings_x86_64_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_domctl_bind_pt_irq {
    pub machine_irq: u32,
    pub irq_type: u32,
    pub u: xen_domctl_bind_pt_irq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_domctl_bind_pt_irq__bindgen_ty_1 {
    pub isa: xen_domctl_bind_pt_irq__bindgen_ty_1__bindgen_ty_1,
    pub pci: xen_domctl_bind_pt_irq__bindgen_ty_1__bindgen_ty_2,
    pub msi: xen_domctl_bind_pt_irq__bindgen_ty_1__bindgen_ty_3,
    pub spi: xen_domctl_bind_pt_irq__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_bind_pt_irq__bindgen_ty_1__bindgen_ty_1 {
    pub isa_irq: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_bind_pt_irq__bindgen_ty_1__bindgen_ty_2 {
    pub bus: u8,
    pub device: u8,
    pub intx: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_bind_pt_irq__bindgen_ty_1__bindgen_ty_3 {
    pub gvec: u8,
    pub gflags: u32,
    pub gtable: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_bind_pt_irq__bindgen_ty_1__bindgen_ty_4 {
    pub spi: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_memory_mapping {
    pub first_gfn: u64,
    pub first_mfn: u64,
    pub nr_mfns: u64,
    pub add_mapping: u32,
    pub padding: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_ioport_mapping {
    pub first_gport: u32,
    pub first_mport: u32,
    pub nr_ports: u32,
    pub add_mapping: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_domctl_ext_vcpucontext {
    pub vcpu: u32,
    pub size: u32,
    pub syscall32_callback_eip: u64,
    pub sysenter_callback_eip: u64,
    pub syscall32_callback_cs: u16,
    pub sysenter_callback_cs: u16,
    pub syscall32_disables_events: u8,
    pub sysenter_disables_events: u8,
    pub __bindgen_anon_1: xen_domctl_ext_vcpucontext__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_domctl_ext_vcpucontext__bindgen_ty_1 {
    pub mcg_cap: u64,
    pub vmce: hvm_vmce_vcpu,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_set_target {
    pub target: domid_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_cpu_policy {
    pub nr_leaves: u32,
    pub nr_msrs: u32,
    pub leaves: __guest_handle_xen_cpuid_leaf_t,
    pub msrs: __guest_handle_xen_msr_entry_t,
    pub err_leaf: u32,
    pub err_subleaf: u32,
    pub err_msr: u32,
}
pub type xen_domctl_cpu_policy_t = xen_domctl_cpu_policy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_domctl_cpu_policy_t {
    pub p: *mut xen_domctl_cpu_policy_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_domctl_cpu_policy_t {
    pub p: *const xen_domctl_cpu_policy_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_subscribe {
    pub port: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_debug_op {
    pub op: u32,
    pub vcpu: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_hvmcontext_partial {
    pub type_: u32,
    pub instance: u32,
    pub bufsz: u64,
    pub buffer: __guest_handle_uint8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_tsc_info {
    pub tsc_mode: u32,
    pub gtsc_khz: u32,
    pub incarnation: u32,
    pub pad: u32,
    pub elapsed_nsec: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_gdbsx_memio {
    pub pgd3val: u64,
    pub gva: u64,
    pub uva: u64,
    pub len: u32,
    pub gwr: u8,
    pub remain: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_gdbsx_pauseunp_vcpu {
    pub vcpu: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_gdbsx_domstatus {
    pub paused: u8,
    pub vcpu_id: u32,
    pub vcpu_ev: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_domctl_vm_event_op {
    pub op: u32,
    pub mode: u32,
    pub u: xen_domctl_vm_event_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_domctl_vm_event_op__bindgen_ty_1 {
    pub enable: xen_domctl_vm_event_op__bindgen_ty_1__bindgen_ty_1,
    pub version: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_vm_event_op__bindgen_ty_1__bindgen_ty_1 {
    pub port: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_domctl_mem_sharing_op {
    pub op: u8,
    pub u: xen_domctl_mem_sharing_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_domctl_mem_sharing_op__bindgen_ty_1 {
    pub enable: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_audit_p2m {
    pub orphans: u64,
    pub m2p_bad: u64,
    pub p2m_bad: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_set_virq_handler {
    pub virq: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_vcpuextstate {
    pub vcpu: u32,
    pub xfeature_mask: u64,
    pub size: u64,
    pub buffer: __guest_handle_uint64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_set_access_required {
    pub access_required: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_set_broken_page_p2m {
    pub pfn: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_cacheflush {
    pub start_pfn: xen_pfn_t,
    pub nr_pfns: xen_pfn_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_paging_mempool {
    pub size: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_vcpu_msr {
    pub index: u32,
    pub reserved: u32,
    pub value: u64,
}
pub type xen_domctl_vcpu_msr_t = xen_domctl_vcpu_msr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_domctl_vcpu_msr_t {
    pub p: *mut xen_domctl_vcpu_msr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_domctl_vcpu_msr_t {
    pub p: *const xen_domctl_vcpu_msr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_vcpu_msrs {
    pub vcpu: u32,
    pub msr_count: u32,
    pub msrs: __guest_handle_xen_domctl_vcpu_msr_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_vnuma {
    pub nr_vnodes: u32,
    pub nr_vmemranges: u32,
    pub nr_vcpus: u32,
    pub pad: u32,
    pub vdistance: __guest_handle_uint,
    pub vcpu_to_vnode: __guest_handle_uint,
    pub vnode_to_pnode: __guest_handle_uint,
    pub vmemrange: __guest_handle_xen_vmemrange_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_psr_cmt_op {
    pub cmd: u32,
    pub data: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_domctl_monitor_op {
    pub op: u32,
    pub event: u32,
    pub u: xen_domctl_monitor_op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_domctl_monitor_op__bindgen_ty_1 {
    pub mov_to_cr: xen_domctl_monitor_op__bindgen_ty_1__bindgen_ty_1,
    pub mov_to_msr: xen_domctl_monitor_op__bindgen_ty_1__bindgen_ty_2,
    pub guest_request: xen_domctl_monitor_op__bindgen_ty_1__bindgen_ty_3,
    pub debug_exception: xen_domctl_monitor_op__bindgen_ty_1__bindgen_ty_4,
    pub vmexit: xen_domctl_monitor_op__bindgen_ty_1__bindgen_ty_5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_monitor_op__bindgen_ty_1__bindgen_ty_1 {
    pub index: u8,
    pub sync: u8,
    pub onchangeonly: u8,
    pub pad1: u8,
    pub pad2: u32,
    pub bitmask: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_monitor_op__bindgen_ty_1__bindgen_ty_2 {
    pub msr: u32,
    pub onchangeonly: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_monitor_op__bindgen_ty_1__bindgen_ty_3 {
    pub sync: u8,
    pub allow_userspace: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_monitor_op__bindgen_ty_1__bindgen_ty_4 {
    pub sync: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_monitor_op__bindgen_ty_1__bindgen_ty_5 {
    pub sync: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_psr_alloc {
    pub cmd: u32,
    pub target: u32,
    pub data: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_vuart_op {
    pub cmd: u32,
    pub type_: u32,
    pub gfn: u64,
    pub console_domid: domid_t,
    pub pad: [u8; 2usize],
    pub evtchn: evtchn_port_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xen_domctl_vmtrace_op {
    pub cmd: u32,
    pub vcpu: u32,
    pub key: u64,
    pub value: u64,
}
pub type xen_domctl_vmtrace_op_t = xen_domctl_vmtrace_op;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_domctl_vmtrace_op_t {
    pub p: *mut xen_domctl_vmtrace_op_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_domctl_vmtrace_op_t {
    pub p: *const xen_domctl_vmtrace_op_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xen_domctl {
    pub cmd: u32,
    pub interface_version: u32,
    pub domain: domid_t,
    pub _pad: [u16; 3usize],
    pub u: xen_domctl__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xen_domctl__bindgen_ty_1 {
    pub createdomain: xen_domctl_createdomain,
    pub getdomaininfo: xen_domctl_getdomaininfo,
    pub getpageframeinfo3: xen_domctl_getpageframeinfo3,
    pub nodeaffinity: xen_domctl_nodeaffinity,
    pub vcpuaffinity: xen_domctl_vcpuaffinity,
    pub shadow_op: xen_domctl_shadow_op,
    pub max_mem: xen_domctl_max_mem,
    pub vcpucontext: xen_domctl_vcpucontext,
    pub getvcpuinfo: xen_domctl_getvcpuinfo,
    pub max_vcpus: xen_domctl_max_vcpus,
    pub scheduler_op: xen_domctl_scheduler_op,
    pub setdomainhandle: xen_domctl_setdomainhandle,
    pub setdebugging: xen_domctl_setdebugging,
    pub irq_permission: xen_domctl_irq_permission,
    pub iomem_permission: xen_domctl_iomem_permission,
    pub ioport_permission: xen_domctl_ioport_permission,
    pub hypercall_init: xen_domctl_hypercall_init,
    pub settimeoffset: xen_domctl_settimeoffset,
    pub tsc_info: xen_domctl_tsc_info,
    pub hvmcontext: xen_domctl_hvmcontext,
    pub hvmcontext_partial: xen_domctl_hvmcontext_partial,
    pub address_size: xen_domctl_address_size,
    pub sendtrigger: xen_domctl_sendtrigger,
    pub get_device_group: xen_domctl_get_device_group,
    pub assign_device: xen_domctl_assign_device,
    pub bind_pt_irq: xen_domctl_bind_pt_irq,
    pub memory_mapping: xen_domctl_memory_mapping,
    pub ioport_mapping: xen_domctl_ioport_mapping,
    pub ext_vcpucontext: xen_domctl_ext_vcpucontext,
    pub set_target: xen_domctl_set_target,
    pub subscribe: xen_domctl_subscribe,
    pub debug_op: xen_domctl_debug_op,
    pub vm_event_op: xen_domctl_vm_event_op,
    pub mem_sharing_op: xen_domctl_mem_sharing_op,
    pub cpu_policy: xen_domctl_cpu_policy,
    pub vcpuextstate: xen_domctl_vcpuextstate,
    pub vcpu_msrs: xen_domctl_vcpu_msrs,
    pub access_required: xen_domctl_set_access_required,
    pub audit_p2m: xen_domctl_audit_p2m,
    pub set_virq_handler: xen_domctl_set_virq_handler,
    pub gdbsx_guest_memio: xen_domctl_gdbsx_memio,
    pub set_broken_page_p2m: xen_domctl_set_broken_page_p2m,
    pub cacheflush: xen_domctl_cacheflush,
    pub gdbsx_pauseunp_vcpu: xen_domctl_gdbsx_pauseunp_vcpu,
    pub gdbsx_domstatus: xen_domctl_gdbsx_domstatus,
    pub vnuma: xen_domctl_vnuma,
    pub psr_cmt_op: xen_domctl_psr_cmt_op,
    pub monitor_op: xen_domctl_monitor_op,
    pub psr_alloc: xen_domctl_psr_alloc,
    pub vuart_op: xen_domctl_vuart_op,
    pub vmtrace_op: xen_domctl_vmtrace_op,
    pub paging_mempool: xen_domctl_paging_mempool,
    pub pad: [u8; 128usize],
}
pub type xen_domctl_t = xen_domctl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_xen_domctl_t {
    pub p: *mut xen_domctl_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __guest_handle_const_xen_domctl_t {
    pub p: *const xen_domctl_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ioreq {
    pub addr: u64,
    pub data: u64,
    pub count: u32,
    pub size: u32,
    pub vp_eport: u32,
    pub _pad0: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub type_: u8,
}
impl ioreq {
    #[inline]
    pub fn state(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn data_is_ptr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_data_is_ptr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dir(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dir(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn df(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_df(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _pad1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__pad1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: u8,
        data_is_ptr: u8,
        dir: u8,
        df: u8,
        _pad1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let state: u8 = unsafe { ::core::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let data_is_ptr: u8 = unsafe { ::core::mem::transmute(data_is_ptr) };
            data_is_ptr as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dir: u8 = unsafe { ::core::mem::transmute(dir) };
            dir as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let df: u8 = unsafe { ::core::mem::transmute(df) };
            df as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let _pad1: u8 = unsafe { ::core::mem::transmute(_pad1) };
            _pad1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ioreq_t = ioreq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shared_iopage {
    pub vcpu_ioreq: [ioreq; 1usize],
}
pub type shared_iopage_t = shared_iopage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buf_ioreq {
    pub type_: u8,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub data: u32,
}
impl buf_ioreq {
    #[inline]
    pub fn pad(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dir(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dir(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn addr(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_addr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pad: u8,
        dir: u8,
        size: u8,
        addr: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pad: u8 = unsafe { ::core::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dir: u8 = unsafe { ::core::mem::transmute(dir) };
            dir as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let size: u8 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let addr: u32 = unsafe { ::core::mem::transmute(addr) };
            addr as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type buf_ioreq_t = buf_ioreq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buffered_iopage {
    pub read_pointer: u32,
    pub write_pointer: u32,
    pub buf_ioreq: [buf_ioreq_t; 511usize],
}
pub type buffered_iopage_t = buffered_iopage;
pub const xenbus_state_XenbusStateUnknown: xenbus_state = 0;
pub const xenbus_state_XenbusStateInitialising: xenbus_state = 1;
pub const xenbus_state_XenbusStateInitWait: xenbus_state = 2;
pub const xenbus_state_XenbusStateInitialised: xenbus_state = 3;
pub const xenbus_state_XenbusStateConnected: xenbus_state = 4;
pub const xenbus_state_XenbusStateClosing: xenbus_state = 5;
pub const xenbus_state_XenbusStateClosed: xenbus_state = 6;
pub const xenbus_state_XenbusStateReconfiguring: xenbus_state = 7;
pub const xenbus_state_XenbusStateReconfigured: xenbus_state = 8;
pub type xenbus_state = xen_bindings_x86_64_types::c_uint;
pub use self::xenbus_state as XenbusState;
